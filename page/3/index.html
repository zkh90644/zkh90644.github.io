<!doctype html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/18/继续学习GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/18/继续学习GCD/" itemprop="url">继续学习GCD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-18T20:06:00+08:00">
                2016-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本着虚心学习的原则，在上次看完GCD后，在码代码的过程中，经常会在dispatch后自动跳出函数列中看到带有context，但是在平常的自学过程中，都没有见到过带有context的参数。那他到底指的是啥？</p>
<p>带着这个好奇心，我努力的爬遍了网上我能找到的相关文档。然而相关的资料很少，最后没办法只能去苹果的官方文档上找，最终大概的了解了这个context的作用。（果然，最原始的才是最有效的。）</p>
<p>在官方文档中有这么一个方法<code>void dispatch_async_f( dispatch_queue_t queue, void *context, dispatch_function_t work)</code>,这个方法和我们日常搜用的<code>dispatch_async</code>类似，唯一的区别的就是中间增加了context这个参数。</p>
<blockquote>
<p>画外音：不是<code>dispatch_async</code>中用的是<code>block</code>，<code>dispatch_async_f</code>中用的是work么？</p>
<p>答：这两个反正都是为了引用一个代码块，实际上的作用基本上都差不多的啦</p>
</blockquote>
<p>而苹果对于这个context的解释是这样的：</p>
<blockquote>
<p>The application-defined context parameter to pass to the function.</p>
<p>将程序中定义的上下文传递给参数。</p>
</blockquote>
<p>那么新的问题又来了，既然他是将上下文传递给参数，我们在OC编码的过程中，主要还是基于Foundation框架，也就是所有对象继承与NSObject对象，但是他是一个OC对象，而这个context所需要的内容是一个基于C语言的指针。那么如果将OC对象转化成C呢？</p>
<blockquote>
<p>画外音：我就是不用OC，我用C的malloc也是可以的啊</p>
<p>你出去！</p>
</blockquote>
<p>正如我们所知道的，OC是C的拓展，让C拥有了面向对象的作用，从而大大提高的程序员开发的效率。同时苹果为了更方便的让开发者使用OC这门语言，他们在<strong>iOS 5</strong>以后加入到LLVM 3.0编译器的。同时使用ARC能够解决开发者心烦的手动管理内存问题，这极大的方便了程序猿们。</p>
<p>而C因为没有ARC机制，所以解决前面这个问题的方法就是：</p>
<p>将这个需要传输的对象的内存管理，从ARC手中抢过来。让我们手动来管理，这样就可以愉快的将变量以C的形式传入进去啦~~~</p>
<p>那么既然要解决这个问题，我们就需要寻找，如何将内存管理从ARC中“夺”过来。</p>
<p>在翻遍了许多网页后，这几个函数引入我眼帘：此处<a href="http://blog.csdn.net/chinahaerbin/article/details/9471419" target="_blank" rel="external">参考原文</a></p>
<ul>
<li>__bridge：只做类型转换，不修改需要管理的内存使用权</li>
<li>__bridge_retained：做类型转换Core Foundation-&gt;OC对象，同时将管理权从ARC中移除，后期需要对对象进行手动释放</li>
<li>__bridge_transfer：做类型转换OC对象-&gt;Core Foundation，同时将管理权移回ARC</li>
</ul>
<p><strong>首先展示显示失败的代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//Data.h</div><div class="line"></div><div class="line">@property(nonatomic,assign)int number;</div><div class="line"></div><div class="line">//Data.m</div><div class="line"></div><div class="line">-(void)dealloc&#123;</div><div class="line">    NSLog(@&quot;the Data dealloc...&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//ViewController - viewDidLoad</div><div class="line"></div><div class="line">- (void)gcdTest1&#123;</div><div class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;helloworld&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    Data *myDate = [[Data alloc]init];</div><div class="line"></div><div class="line">    myDate.number = 20;</div><div class="line"></div><div class="line">    dispatch_set_context(queue, (__bridge void *)myDate);</div><div class="line"></div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        Data *data = (__bridge Data*)dispatch_get_context(queue);</div><div class="line">        NSLog(@&quot;%d&quot;,data.number);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    myDate = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>失败原因：</strong>由于我们在这里设置为了nil也就是意味着我们将他释放，但是在线程中的data还是调用者，同时因为c中对ARC不进行操作，所以，线程中的data指向的地址出现问题，所以出现<code>EXC_BAD_ACCESS</code></p>
<p>console中的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-07-18 21:29:35.946 GCD-OC[65571:7506303] the Data dealloc...</div><div class="line">2016-07-18 21:29:35.946 GCD-OC[65571:7506809] 20</div><div class="line">(出现内存问题)</div></pre></td></tr></table></figure>
<p><strong>正确解释的代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)gcdTest1&#123;</div><div class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;helloworld&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    Data *myDate = [[Data alloc]init];</div><div class="line"></div><div class="line">    myDate.number = 20;</div><div class="line"></div><div class="line">    dispatch_set_context(queue, (__bridge_retained void*)myDate);</div><div class="line"></div><div class="line">    dispatch_set_finalizer_f(queue, &amp;cleanMyMemory);</div><div class="line"></div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        Data *data = (__bridge Data*)dispatch_get_context(queue);</div><div class="line">        NSLog(@&quot;%d&quot;,data.number);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void cleanMyMemory(void *context)&#123;</div><div class="line">    Data *data = (__bridge_transfer Data*)context;</div><div class="line">    data = nil;</div><div class="line">    NSLog(@&quot;clean the data&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>正确的输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-07-18 21:39:52.148 GCD-OC[65742:7528074] 20</div><div class="line">2016-07-18 21:39:52.149 GCD-OC[65742:7528074] the Data dealloc...</div><div class="line">2016-07-18 21:39:52.149 GCD-OC[65742:7528074] clean the data</div></pre></td></tr></table></figure>
<p>以上就是Context的基本使用方法，看完之后各位看官们就能愉快的将OC对象作为参数传到已经准备好的dispatch对象的执行函数中了~~~~然而具体如何使用，这个根据具体开发环境决定。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/17/浅谈GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/17/浅谈GCD/" itemprop="url">浅谈GCD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-17T16:36:00+08:00">
                2016-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>GCD对于iOS开发者来说肯定不陌生，他和NSThread，NSOperation一起作为iOS开发中主要的三种多线程实现方法，而GCD是最最底层的，所以对于作为一个iOSer，GCD是必须掌握的。</p>
</blockquote>
<p>我通过对于以下两篇文章的阅读，基本上掌握了GCD的基本使用方法。所以首先感谢两位作者。</p>
<ul>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md" target="_blank" rel="external">GCD 深入理解：第一部分</a></li>
<li><a href="http://blog.csdn.net/CHENYUFENG1991/article/details/51786697" target="_blank" rel="external">iOS多线程开发——GCD的使用与多线程开发浅析（二）</a></li>
</ul>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="##一、基本概念"></a>##一、基本概念</h2><p>对于新手来说，最常见同时最容易搞混的的莫过于GCD中的一些基本概念了。</p>
<ol>
<li><p>并行与并发（Parallelism &amp;&amp; Concurrency）</p>
<ul>
<li>并行：顾名思义就是同时行动，两个任务在两个线程（Thread）上进行处理，彼此互不干涉。而究其根本是因为<strong>多核进行处理</strong>，从而更快的解决任务。（可以类比于两条水管中同时给游泳池放水）</li>
<li>并发：顾名思义，同时发生。对于有的性能较差的机子，比如说那些只有单核的设备，为了让用户<strong>感觉能够同时处理多个任务</strong>，他就需要通过不断的切换正在处理的线程，从而实现一种“伪并行”，这样就防止用户因为一个任务进行太久而无法进行下一个任务。（可以类比于我用两个口给游泳池放水，不过因为只有一根水管，而放水的方向有2个方面，所以需要不断的切换，从而实现两边同时达到需要的水位）</li>
<li>区分如下图：<img src="https://camo.githubusercontent.com/55145c5a8cf3d6f840e7267acd550869f92becfe/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f436f6e63757272656e63795f76735f506172616c6c656c69736d2e706e67" alt="两者的区别"></li>
</ul>
</li>
<li><p>串行与并发（Serial &amp;&amp; Concurrent）</p>
<ul>
<li>串行：由于所有任务在一个线程被执行的时候只有一个任务会被执行，所以每个任务都要依赖于先来先处理（FIFO）原则，处理所有得到的内容。</li>
<li>并行：当接收到任务的时候，并行状态下，他会开启多个线程，将每个任务都分配到各个线程中，从而使得每个任务都能够在同一时间被执行。这样有效的减少了所消耗的时间。</li>
<li>区分图如下：</li>
</ul>
<p><img src="https://camo.githubusercontent.com/e337c0cb657dde8d7eeb5468a1724c751cedb484/687474703a2f2f63646e342e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f53657269616c2d51756575652d343830783237322e706e67" alt="串行"><img src="https://camo.githubusercontent.com/607942d30c4701a1a721781264fa815f100668a5/687474703a2f2f63646e332e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f436f6e63757272656e742d51756575652d343830783237322e706e67" alt="并行"></p>
</li>
<li><p><strong>队列：</strong>就像前面所说，当你告诉电脑你需要执行哪些事情的时候，电脑就会把你告诉他的一件件事情放到自己的队伍中，很明显，先告诉他的事情放在前面，后告诉他的事情放在后面，即先进先处理（FIFO）原则处理所有事物，就像排队一样。</p>
<ul>
<li>在GCD中主要的队列有2种，就是前面提到的：<ul>
<li>串行队列</li>
<li>并发队列</li>
</ul>
</li>
<li>苹果公司提供给我们的已存在的队列有5种（不包括后期我们自己添加的内容）<ul>
<li>主队列（main queue）：默认情况下所有事情都是在主队列下进行处理，只要有编码经验的人来说，主队列很明显是（串行队列）。</li>
<li>全局调度队列（Global Dispatch Queues）:默认情况下全局队列是系统提供的并发队列的统称，根据队列的优先程度不同分为以下几个（优先度从低到高）：<ul>
<li>background</li>
<li>low</li>
<li>default</li>
<li>high</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同步与异步（synchronization &amp;&amp; asynchronous）<br>-同步：同步指的是在原来的内容执行完成之后，再执行你下面所需要的任务。<br>-异步：异步指的是在和原来的内容执行的同时，在另一个地方同时处理新的任务。</p>
<p>​<br>##二、基本使用</p>
</li>
</ol>
<hr>
<p>既然学了，那肯定要使用它。那么我们先模拟一个环境：<br>这个程序里面只有主队列，然后你想从网上下载一个图片，放到你自己的手机里面，然后用户就可以对手机里面的这张图片进行各种各样的处理。<br>但是问题来了：我们都知道下载需要时间，虽然现在已经是4G时代，下载速度很快，但是如果这个图片很大，那么他就需要很长的时间来进行等待。而在这段时间内，用户什么事情都不能干，只能默默的干等着。</p>
<p><strong>这很明显是一个很差的用户体验</strong></p>
<p>那么既然我们已经知道问题所在，就需要想办法解决它：</p>
<ol>
<li>我们需要在用户等待的时候添加一个动画效果，告诉他我们正在下载（这个和今天主题无关，我们就不继续深入了解）</li>
<li>将下载任务放到后台（如果仍旧放在前台的话，就算有动画，动画效果也不会动）</li>
</ol>
<p><strong>那么这个时候就需要异步队列的存在了</strong></p>
<hr>
<p>就像前面的基本概念中所提到的，执行分为同步执行和异步执行，任务队列分为串行队列和并发队列。所以他们彼此一一结合，总共有4种情况存在，主要的彼此结合的状态图如下所示：</p>
<p><img src="http://img.blog.csdn.net/20151105111413919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="队列区别"></p>
<p>###单队列</p>
<p>####串行队列，同步执行<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func serialDispatchQueueWithSync() &#123;</div><div class="line">    let queue = dispatch_queue_create(&quot;serialDispatchQueue&quot;, DISPATCH_QUEUE_SERIAL)</div><div class="line"></div><div class="line">    print(&quot;0&quot;)</div><div class="line"></div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;1&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;2&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;3&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;4&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;5&quot;)</div><div class="line">    &#125;</div><div class="line">	print(&quot;6&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td></tr></table></figure>
<h4 id="串行队列，异步执行"><a href="#串行队列，异步执行" class="headerlink" title="串行队列，异步执行"></a>串行队列，异步执行</h4><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func serialDispatchQueueWithASync() &#123;</div><div class="line">    let queue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL)</div><div class="line"></div><div class="line">    print(&quot;0&quot;)</div><div class="line"></div><div class="line">	dispatch_async(queue) &#123;</div><div class="line">        print(&quot;1&quot;)</div><div class="line">	&#125;</div><div class="line">    dispatch_async(queue) &#123;</div><div class="line">        print(&quot;2&quot;)</div><div class="line">	&#125;</div><div class="line">	dispatch_async(queue) &#123;</div><div class="line">        print(&quot;3&quot;)</div><div class="line">	&#125;</div><div class="line">	dispatch_async(queue) &#123;</div><div class="line">        print(&quot;4&quot;)</div><div class="line">	&#125;</div><div class="line">	dispatch_async(queue) &#123;</div><div class="line">        print(&quot;5&quot;)</div><div class="line">	&#125;</div><div class="line">	dispatch_async(queue) &#123;</div><div class="line">        print(&quot;6&quot;)</div><div class="line">	&#125;</div><div class="line">    print(&quot;7&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">7</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>解释：因为queue是异步执行的，即调用dispatch_async函数，所以输出1 2 3 4 5 6的时候是在另一个线程中的，所以和主线程中的输出1 7 无关。</p>
<p>####并发队列，同步执行<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func concurrentDispatchsQueueWithSync() &#123;</div><div class="line">    let queue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT)</div><div class="line"></div><div class="line">    print(&quot;0&quot;)</div><div class="line"></div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;1&quot;)</div><div class="line">        print(&quot;12&quot;)</div><div class="line">        print(&quot;13&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;2&quot;)</div><div class="line">        print(&quot;22&quot;)</div><div class="line">        print(&quot;23&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;3&quot;)</div><div class="line">        print(&quot;32&quot;)</div><div class="line">        print(&quot;33&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_sync(queue) &#123;</div><div class="line">        print(&quot;4&quot;)</div><div class="line">        print(&quot;42&quot;)</div><div class="line">        print(&quot;43&quot;)</div><div class="line">    &#125;</div><div class="line">	print(&quot;5&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">12</div><div class="line">13</div><div class="line">2</div><div class="line">22</div><div class="line">23</div><div class="line">3</div><div class="line">32</div><div class="line">33</div><div class="line">4</div><div class="line">42</div><div class="line">43</div><div class="line">5</div></pre></td></tr></table></figure>
<h4 id="并发队列，异步执行"><a href="#并发队列，异步执行" class="headerlink" title="并发队列，异步执行"></a>并发队列，异步执行</h4><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func concurrentDispatchsQueueWithASync() &#123;</div><div class="line">    let queue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT)</div><div class="line"></div><div class="line">    print(&quot;0&quot;)</div><div class="line"></div><div class="line">    dispatch_async(queue) &#123;</div><div class="line">        print(&quot;1&quot;)</div><div class="line">        print(&quot;12&quot;)</div><div class="line">        print(&quot;13&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_async(queue) &#123;</div><div class="line">        print(&quot;2&quot;)</div><div class="line">        print(&quot;22&quot;)</div><div class="line">        print(&quot;23&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_async(queue) &#123;</div><div class="line">        print(&quot;3&quot;)</div><div class="line">        print(&quot;32&quot;)</div><div class="line">        print(&quot;33&quot;)</div><div class="line">    &#125;</div><div class="line">    dispatch_async(queue) &#123;</div><div class="line">        print(&quot;4&quot;)</div><div class="line">        print(&quot;42&quot;)</div><div class="line">        print(&quot;43&quot;)</div><div class="line">    &#125;</div><div class="line">	print(&quot;5&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">7</div><div class="line">1</div><div class="line">2</div><div class="line">12</div><div class="line">3</div><div class="line">22</div><div class="line">13</div><div class="line">4</div><div class="line">32</div><div class="line">23</div><div class="line">5</div><div class="line">42</div><div class="line">33</div><div class="line">52</div><div class="line">43</div><div class="line">53</div></pre></td></tr></table></figure>
<p>####其他常见用法：</p>
<p>#####挂起与恢复</p>
<ul>
<li>线程挂起：<code>dispatch_suspnd()</code></li>
<li>线程恢复：<code>dispatch_resume()</code></li>
</ul>
<p>#####信号量<br>由于有的时候（比如说在创建添加数组中的对象的时候），因为不同线程操纵的是同一个对象，所以很容易发生报错，这个时候需要通过信号量来对对应的内容进行控制，当<strong>信号量为0</strong>的时候，进入等待状态，不能执行下面的内容；当<strong>信号量为1</strong>的时候，可以执行，同时信号量减一，等到执行完毕，信号量加一。</p>
<ul>
<li>等待执行<code>dispatch_semaphore_wait()</code></li>
<li>信号量加一 <code>dispatch_semahore_signal</code></li>
</ul>
<p>####只执行一次<br>有的时候，有的东西的创建只能被创建一次（即单例），这个时候就需要用到<code>dispatch_once()</code><br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var token: dispatch_once_t = 0</div><div class="line">func test() &#123;</div><div class="line">    dispatch_once(&amp;token) &#123;</div><div class="line">        println(&quot;This is printed only on the first call to test()&quot;)</div><div class="line">    &#125;</div><div class="line">    println(&quot;This is printed for each call to test()&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####关于读写问题的解决方法（买票问题）<br>由于日常编码的过程中经常会遇到，当你在调用这个这个变量的时候。另一个线程也在调用这个变量（只在并发过程中），如果两个线程都是在读取数据，那并没有什么问题，但是如果其中一个在写入，或者两个都在写入，那么就会出现很大问题，所以苹果官方在GCD中也给我们准备了一个方法，让我们解决这个问题，那就是<code>dispatch_barrier_async</code>，这个方法让对的内容在并发过程中加入，从而方便组织内容的修改，从而使得对应的内容只能在当前线程中被进行修改。</p>
<p><img src="https://camo.githubusercontent.com/9cb07ac740e4a46fb69777e3ccd982ef23072403/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f44697370617463682d426172726965722d343830783237322e706e67" alt="dispatch_barrier_async"></p>
<p>####常见问题：</p>
<p>#####死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let queue = dispatch_get_main_queue()</div><div class="line"></div><div class="line">dispatch_async(queue) &#123;</div><div class="line">	dispatch_sync(queue, &#123;</div><div class="line">		print(&quot;1&quot;)</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>产生原理：因为<code>dispatch_sync()</code>会等到本身结束之后才会在主线程继续执行接下去的代码，但是<code>dispatch_sync()</code>这个方法调用的就是主线程，所以午饭等到主线程结束，所以就无法返回，就会卡在这里。</p>
<p>解释：由于是并发队列，所以他会创建多个线程，从而保证每个线程的任务都能够尽快完成，所以顺序有一定的出入。</p>
<p>####最后通过两张动态图来最后总结单队列：</p>
<p>#####dispatch_sync</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">  [super viewDidLoad];</div><div class="line"></div><div class="line">  dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line"></div><div class="line">  	NSLog(@&quot;First Log&quot;);</div><div class="line"></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  NSLog(@&quot;Second Log&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://camo.githubusercontent.com/4156bf1f7dce14ea2d485d9bc531b91b8832e326/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f64697370617463685f73796e635f696e5f616374696f6e2e676966" alt="dispatch_sync"></p>
<ol>
<li>主队列按照预定的顺序下来</li>
<li>viewDidLoad在主线程进行执行。</li>
<li>直到执行到<code>dispatch_sync</code></li>
<li>调用<code>dispatch_sync</code>代码，将block添加到全局队列中，主队列挂起。</li>
<li>全局队列先完成之前存放在全局队列中的内容。</li>
<li>完成之前的任务后，执行<code>dispatch_sync</code>的block中的内容。</li>
<li>完成block中的任务，主队列上的任务得以恢复</li>
<li>主队列继续执行其他任务。</li>
</ol>
<p>#####dispatch_async</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">  [super viewDidLoad];</div><div class="line"></div><div class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line"></div><div class="line">	NSLog(@&quot;First Log&quot;);</div><div class="line"></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  NSLog(@&quot;Second Log&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">![dispatch_sync](https://camo.githubusercontent.com/2c7cbaf76001a56622e14cf48a8d914d4b5c9df4/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f64697370617463685f6173796e635f696e5f616374696f6e2e676966)</div></pre></td></tr></table></figure>
<ol>
<li>主队列一路按顺序执行任务——接着是一个实例化<code>UIViewController</code> 的任务，其中包含了<code>viewDidLoad</code>。</li>
<li><code>viewDidLoad</code>在主线程执行。</li>
<li>主线程目前在<code>viewDidLoad</code>内，正要到达<code>dispatch_async</code>。</li>
<li><code>dispatch_async Block</code>被添加到一个全局队列中，将在稍后执行。</li>
<li><code>viewDidLoad</code>在添加<code>dispatch_async</code>到全局队列后继续进行，主线程把注意力转向剩下的任务。同时，全局队列并发地处理它未完成地任务。记住<code>Block</code>在全局队列中将按照（FIFO）顺序出列，但可以并发执行。</li>
<li>添加到<code>dispatch_async</code>的代码块开始执行。</li>
<li><code>dispatch_async Block</code>完成，两个<code>NSLog</code>语句将它们的输出放在控制台上。</li>
</ol>
<p>###调度组<br>既然能够处理一个个的任务，那么我们就继续模拟一个环境，当我们需要在网上下载内容的时候（这些内容需要彼此联系在一起才能正常使用），这个时候，上面的单队列就不够了（或者说如果使用单队列产生的效果不是时间太长，就是文件的完整性不够好）</p>
<p>这个时候我们就需要引入多队列，当多个内容都处理完成之后，让系统告诉我们，我们已经完成了以上的下载。可以继续做下一步事情了。</p>
<p>####任务开始<br>在GCD中，我们可以通过<code>dispatch_group_enter</code>来通知当前任务的开始，而与之相对应的，我们必须在任务完成后，手动通知调度组任务结束（<code>dispatch_group_leave</code>）这样才能让调度组知道我们这个任务已经结束。</p>
<p>代码如下(由于demo中有一个Photo类，所以此处贴上OC代码)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_group_enter(downloadGroup); // 3</div><div class="line">Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) &#123;</div><div class="line">	if (_error) &#123;</div><div class="line">    	error = _error;</div><div class="line">	&#125;</div><div class="line">dispatch_group_leave(downloadGroup); // 4</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[[PhotoManager sharedManager] addPhoto:photo];</div></pre></td></tr></table></figure>
<p>####任务提醒<br>当我们所有的任务都手动通知后，那么就需要条用提醒来告诉他（我已经完成了所有内容，接下去需要试试哪里能够执行了），而提醒方式在GCD中有两种：</p>
<ul>
<li><code>dispatch_group_wait() + dispatch_async()</code></li>
<li><code>dispatch_group_notify</code></li>
</ul>
<p>####其他常见用法</p>
<p>#####dispatch_apply()<br>有的时候需要调用for循环来反复执行，但是当需要执行的代码量偏大的时候，for的效率比较低，这个时候需要用<code>dispatch_apply()</code>来执行，这样节省效率，不过当需要执行的代码量比较小的时候，<code>dispatch_apply()</code>的效率就比较差了。</p>
<blockquote>
<p>这个方法的效果和<code>dispatch_sync</code>一样，所以要注意<strong>死锁</strong>（后面会提到）</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/17/浅谈NSOperation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/17/浅谈NSOperation/" itemprop="url">浅谈NSOperation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-17T16:36:00+08:00">
                2016-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>就如同上一篇文章——<a href="http://blog.csdn.net/zkh90644/article/details/51934062" target="_blank" rel="external">《iOS多线程编程——浅谈GCD》</a>中写到的,iOS的多线程开发中，最常用的就是NSThread，NSOperation，GCD，他们的抽象层次从左往右越来越高，这也就是越来越底层，性能也就越来越好。既然上次谈到了GCD，那么这次就不得不来谈谈他的兄弟NSOperation。</p>
<p>苹果官方文档是这样描述NSOperation的：</p>
<blockquote>
<p>The NSOperation class is an abstract class you use to encapsulate the code and data associated with a single task. Because it is abstract, you do not use this class directly but instead subclass or use one of the system-defined subclasses (NSInvocationOperation or NSBlockOperation) to perform the actual task. Despite being abstract, the base implementation of NSOperation does include significant logic to coordinate the safe execution of your task. The presence of this built-in logic allows you to focus on the actual implementation of your task, rather than on the glue code needed to ensure it works correctly with other system objects.</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>NSOperation类是一个抽象类，通过这个类，你可以在一个任务将代码和数据联系起来。又因为他是抽象的，你不能直接使用它，而是使用它的子类（<code>NSinvocationOperation</code>和<code>NSBlockOperation</code>）或者自定义一个子类来实现它实际上的任务。尽管他是抽象的，但是他最基本的方法包含了主要逻辑来保证线程安全。这使得你只要专心于你想要实现的逻辑处理，而不用关心用来处理连接的代码在这个工程中是否正确。</p>
</blockquote>
<p>对于<code>NSOperation</code>，实际上他仅仅是一个抽象类。他的兄弟<code>NSBlockOperation</code>和<code>NSInvocationOperation</code>才是我们日常编码过程中用到最多的两个Operation对象。<br>也就是说，如果真的要调用NSOperation对象的话，我们有3种方法：</p>
<ol>
<li>使用NSInvocationOperation</li>
<li>使用NSBlockOperation</li>
<li>自己继承NSOperation，然后实现对应的内容</li>
</ol>
<p>既然如此，我们就一个个来讲讲，让我们更加简单的了解NSOperation这个东西吧。</p>
<h2 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="##NSInvocationOperation"></a>##NSInvocationOperation</h2><p>###基本使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)operationJustStart&#123;</div><div class="line">    NSInvocationOperation * operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run:) object:@&quot;hei&quot;]; //1</div><div class="line"></div><div class="line">    [operation setCompletionBlock:^&#123;	//2</div><div class="line">        NSLog(@&quot;helloworld&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [operation start];	//3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ol>
<li>用来创建一个<code>NSInvocationOperation</code>对象，同时将执行时候的代码设置为run函数，并将参数中的object所指向的对象作为run函数的参数传入。</li>
<li>设置当该线程完成后，需要执行的代码块（Block）</li>
<li>线程开始。NSInvocationOperation中，如果直接使用<code>start</code>函数的话，那么就会直接在当前线程直接执行对应的代码（同步执行）</li>
</ol>
<p><strong>坑：</strong></p>
<ol>
<li>只能同步执行，如果需要使用异步，那么就需要调用NSOperationQueue。</li>
<li>CompletionBlock的调用是在完成后一段时间后进行调用的，这个可能和<strong>runloop</strong>有关，这里先开个坑。一下是坑的代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    [self operationJustStart];</div><div class="line"></div><div class="line">    NSLog(@&quot;2&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)operationJustStart&#123;</div><div class="line">    NSInvocationOperation * operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run:) object:@&quot;hei&quot;];</div><div class="line"></div><div class="line">    [operation setCompletionBlock:^&#123;</div><div class="line">        NSLog(@&quot;helloworld&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [operation start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)run:(NSObject *)obj&#123;</div><div class="line">    for (int i = 0 ; i &lt; 10; i++) &#123;</div><div class="line">        NSLog(@&quot;%d %s&quot;,i,__func__);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2016-07-18 13:09:11.344 NSOperation[59291:6646533] 1</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 0 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 1 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 2 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 3 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 4 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 5 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.345 NSOperation[59291:6646533] 6 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.346 NSOperation[59291:6646533] 7 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.346 NSOperation[59291:6646533] 8 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.346 NSOperation[59291:6646533] 9 -[ViewController run:]</div><div class="line">2016-07-18 13:09:11.346 NSOperation[59291:6646533] 2</div><div class="line">2016-07-18 13:09:11.346 NSOperation[59291:6646590] helloworld</div></pre></td></tr></table></figure>
<p>####注意！！！如果对一个NSOperation对象两次使用start方法，那么第二次调用将失败。因为此时operation已经被销毁。</p>
<h3 id="使用NSOperationQueue进行异步调用"><a href="#使用NSOperationQueue进行异步调用" class="headerlink" title="使用NSOperationQueue进行异步调用"></a>使用NSOperationQueue进行异步调用</h3><p><strong>代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)InvocationOperation&#123;</div><div class="line">    NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&quot;hello&quot;];</div><div class="line">    [operation setCompletionBlock:^&#123;</div><div class="line">        NSLog(@&quot;setCompletionBlock&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line"></div><div class="line">    NSInvocationOperation *operation2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&quot;world&quot;];</div><div class="line">    [operation2 setCompletionBlock:^&#123;</div><div class="line">        NSLog(@&quot;setCompletionBlock&quot;);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line"></div><div class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</div><div class="line"></div><div class="line">    [queue addOperation:operation];</div><div class="line">    [queue addOperation:operation2];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)run:(NSObject *)obj&#123;</div><div class="line">    for (int i = 0 ; i &lt; 10; i++) &#123;</div><div class="line">        NSLog(@&quot;%d %s&quot;,i,__func__);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>调用的结果如下</strong>：(很明显是异步调用，同时，是开了2个线程，毕竟2个operation嘛)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">2016-07-18 13:14:56.145 NSOperation[59346:6655570] 1</div><div class="line">2016-07-18 13:14:56.145 NSOperation[59346:6655570] 2</div><div class="line">2016-07-18 13:14:56.145 NSOperation[59346:6655619] 0 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.145 NSOperation[59346:6655609] 0 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655619] 1 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655609] 1 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655619] 2 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655609] 2 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655619] 3 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655609] 3 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655619] 4 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655609] 4 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655619] 5 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655619] 6 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.146 NSOperation[59346:6655609] 5 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.147 NSOperation[59346:6655619] 7 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.161 NSOperation[59346:6655619] 8 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.161 NSOperation[59346:6655609] 6 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.162 NSOperation[59346:6655619] 9 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.162 NSOperation[59346:6655609] 7 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.162 NSOperation[59346:6655609] 8 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.162 NSOperation[59346:6655609] 9 -[ViewController run:]</div><div class="line">2016-07-18 13:14:56.162 NSOperation[59346:6655633] setCompletionBlock</div><div class="line">2016-07-18 13:14:56.162 NSOperation[59346:6655619] setCompletionBlock</div></pre></td></tr></table></figure>
<h2 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="##NSBlockOperation"></a>##NSBlockOperation</h2><p>这个方法根据名字就很容易得到他的概念，他就是可以通过多个block，来实现串行队列。</p>
<p>实现方法的话和前面这个类似，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)blockOperation&#123;</div><div class="line">    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">		[self run];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        [self run];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</div><div class="line"></div><div class="line">    [queue addOperation:operation1];</div><div class="line">    [queue addOperation:operation2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)run:(NSObject *)obj&#123;</div><div class="line">    for (int i = 0 ; i &lt; 10; i++) &#123;</div><div class="line">        NSLog(@&quot;%d %s&quot;,i,__func__);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果如下,很明显是异步的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">2016-07-18 19:35:05.637 NSOperation[64600:7323370] 1</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323370] 2</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323407] 0 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323405] 0 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323407] 1 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323405] 1 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323407] 2 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323405] 2 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323407] 3 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323405] 3 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323407] 4 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.638 NSOperation[64600:7323405] 4 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.639 NSOperation[64600:7323407] 5 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.639 NSOperation[64600:7323405] 5 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.639 NSOperation[64600:7323407] 6 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.639 NSOperation[64600:7323405] 6 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.639 NSOperation[64600:7323407] 7 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.640 NSOperation[64600:7323407] 8 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.640 NSOperation[64600:7323405] 7 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.640 NSOperation[64600:7323407] 9 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.640 NSOperation[64600:7323405] 8 -[ViewController run:]</div><div class="line">2016-07-18 19:35:05.641 NSOperation[64600:7323405] 9 -[ViewController run:]</div></pre></td></tr></table></figure>
<p>而在这里面有一个坑：</p>
<p>也就是如果你在创建block的时候调用了他的operation.name的话，就算你后面再进行设置，他的内容也不会发生改变。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)blockOperation&#123;</div><div class="line">    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        NSLog(@&quot;%@ is complete 1&quot;,operation1.name);</div><div class="line">    &#125;];</div><div class="line">    operation1.name = @&quot;o1&quot;;</div><div class="line"></div><div class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        NSLog(@&quot;%@ is complete 2&quot;,operation1.name);</div><div class="line">    &#125;];</div><div class="line">    operation2.name = @&quot;o2&quot;;</div><div class="line"></div><div class="line"></div><div class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    [queue addOperation:operation1];</div><div class="line">    [queue addOperation:operation2];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2016-07-18 19:40:20.363 NSOperation[64660:7332789] 1</div><div class="line">2016-07-18 19:40:20.364 NSOperation[64660:7332789] 2</div><div class="line">2016-07-18 19:40:20.364 NSOperation[64660:7333007] (null) is complete 1</div><div class="line">2016-07-18 19:40:20.364 NSOperation[64660:7332999] o1 is complete 2</div></pre></td></tr></table></figure>
<h2 id="Custom-Operation"><a href="#Custom-Operation" class="headerlink" title="##Custom Operation"></a>##Custom Operation</h2><blockquote>
<p>最后再来讲讲自定义的Operation</p>
</blockquote>
<p>由于要自定义，而且operation默认情况下是抽象类，所以我们对里面的部分内容必须要得到实现。</p>
<ol>
<li>重写main方法</li>
<li>为了能够顺利的使用NSOperation中的cancel方法，我们需要在main方法中添加isCancel来判断是否被终止，从而确定能够在调用这个线程的时候，顺利终止这个线程。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)main &#123;</div><div class="line">    if (self.isCancelled) return;</div><div class="line"></div><div class="line">    // 获取图片数据</div><div class="line">    NSURL *url = [NSURL URLWithString:self.imageUrl];</div><div class="line">    NSData *imageData = [NSData dataWithContentsOfURL:url];</div><div class="line"></div><div class="line">    if (self.isCancelled) &#123;</div><div class="line">        url = nil;</div><div class="line">        imageData = nil;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 初始化图片</div><div class="line">    UIImage *image = [UIImage imageWithData:imageData];</div><div class="line"></div><div class="line">    if (self.isCancelled) &#123;</div><div class="line">        image = nil;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.delegate respondsToSelector:@selector(downloadFinishWithImage:)]) &#123;</div><div class="line">        // 把图片数据传回到主线程</div><div class="line">        [(NSObject *)self.delegate performSelectorOnMainThread:@selector(downloadFinishWithImage:) withObject:image waitUntilDone:NO];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><hr>
<p>在多线程中还有一个事情是十分重要的，那就是线程同步问题：</p>
<p>这个问题在GCD中可以通过<code>dispatch_barrier_async</code>来是的在那个时间段只能够使用一个代码块。这样就保证数据的安全性。</p>
<p>而在NSOperation，因为我们不需要关心到底</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/12/[译]autolayout_uitableView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/12/[译]autolayout_uitableView/" itemprop="url">iOS中使用autolayout来进行UITableView的布局(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-12T21:53:50+08:00">
                2016-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了更好的使用Autolayout，在开发过程中发现了需要使用UITableViewCell，所以网上爬文。以下是翻译</p>
<p>原文链接：<a href="http://useyourloaf.com/blog/table-view-cells-with-varying-row-heights/" title="Table View Cells with Varying Row Heights" target="_blank" rel="external">点我跳转</a></p>
<p>##使用不同高度的TableViewCell</p>
<p>[我的<a href="http://useyourloaf.com/blog/self-sizing-table-view-cells/" title="Self Sizing Table View Cells" target="_blank" rel="external">这篇文章</a>曾经介绍了iOS8实现这个方式的一个更简单的方法]</p>
<p>我曾经发过文章来介绍使用<strong>动态类型</strong>来增加因为字体大小增大而增大的单元格（cell）的高度。然而这能对那些有着一样高度的单元格（cell）的tableView有效。这篇文章中，我将一步步来使用autolayout来设置不同的cell高度。</p>
<p>在一切开始之前，我将感谢Amy Worrall的<a href="http://blog.amyworrall.com/post/66085151655/using-auto-layout-to-calculate-table-cell-height" title="using auto layout to calculate table cell height" target="_blank" rel="external">这篇文章</a>，因为他启发了我，让我保存了一个Cell的属性，从而使用<code>tableView:heightForRowAtIndexPath:</code>方法来根据内容和获得正确的大小。</p>
<h2 id="Huckleberry（不知道咋翻译ORZ，就当做内容来源来源）"><a href="#Huckleberry（不知道咋翻译ORZ，就当做内容来源来源）" class="headerlink" title="###Huckleberry（不知道咋翻译ORZ，就当做内容来源来源）"></a>###<strong>Huckleberry</strong>（不知道咋翻译ORZ，就当做内容来源来源）</h2><p>作为数据源（Source data）我的内容,我选择了<a href="http://www.gutenberg.org/ebooks/32325" title="Project Gutenberg" target="_blank" rel="external">Project Gutenberg</a>中的前十五章——“The Adventures of Huckleberry Finn”，并将它导入到plist文件中（每一句作为一项）。这个给予我了近2000行不同长度的内容。这是为了展示每个在对应的tableView中的每个句子都有对应的行号。</p>
<p><img src="http://useyourloaf.com/assets/images/2014/2014-02-10-001.png" alt="图片1"></p>
<p>每一个单元格（cell）的高度被要求了不同的行数，这在使用更大的字体设置时更加明显：</p>
<p><img src="http://useyourloaf.com/assets/images/2014/2014-02-10-002.png" alt="图片2"></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="###开始"></a>###开始</h2><p>我们以Xcode中的<strong>单一应用</strong>（single View Application）作为基础，通过一定的改变，使他有一个tableViewController，并嵌入一个UINavigationController中，如下面所示的：</p>
<p><img src="http://useyourloaf.com/assets/images/2014/2014-02-11-001.png" alt="图片1"></p>
<p>###AutoLayout来设置保存的Cell原型<br>为句子的Label增加Autolayout约束，分别约束<strong>左(leading),右(trailing),下(bottom)</strong>的介于单元格（cell）和内容之间的空间。如果你对在<strong>inderface Builder</strong>中使用autolayout不太熟悉的话，还有一些方法来增加约束（在写这篇文章的时候我是用的是Xcode 5.0.2）。你可以在storyboard中点击control按钮同时拖动label到包含它的内容或者在左边的document outline中右键拖动并选择<strong>左(leading),右(trailing),下(bottom)</strong></p>
<p><img src="http://useyourloaf.com/assets/images/2014/2014-02-11-003.png" alt="图片2"></p>
<p>根据你的label的位置，你可能需要调整你的约束来确保他们有一个默认的空间。你能够在右侧的检测器中中检查约束同时设置相应的值。</p>
<p><img src="http://useyourloaf.com/assets/images/2014/2014-02-11-004.png" alt="图片3"></p>
<p>添加进一步的约束在两个label之间来设置他们的垂直空间来设置标准距离，重复以上过程来设置行号和包含他的空间的左、右、上的空间约束。interface builder将报错，你这两个labels在垂直方向有歧义的layout，你能看到这么问题在storyboard左侧的document outline。如果你点击了那个红色的按钮：<br><img src="http://useyourloaf.com/assets/images/2014/2014-02-11-005.png" alt="图片4"></p>
<p>autolayout将不知道我们将会调整内容的大小来保证每个label都合适，因此他希望知道一个暗示来明白哪个label首先应该收缩还是扩张来适应这个空间。为了移除warning，我们将设置行号（label）的较低的垂直压缩阻力同时增加垂直拥抱来是他保持在我们想要的大小<br><img src="http://useyourloaf.com/assets/images/2014/2014-02-12-001.png" alt="图片5"></p>
<p>如果你设置好了以上约束，他看起来大概是这样：<br><img src="http://useyourloaf.com//assets/images/2014/2014-02-14-001.png" alt="图片6"><br><img src="http://useyourloaf.com//assets/images/2014/2014-02-14-002.png" alt="图片7"></p>
<p>###创建类来自定义单元格（cell）<br>创建一个一个新的OC类文件到工程中来自定义tableViewCell，这个类只创建了IBOutlet原型来保存这两个Label</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// UYLTextCell.h</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@interface UYLTextCell : UITableViewCell</div><div class="line">@property (nonatomic, weak) IBOutlet UILabel *numberLabel;</div><div class="line">@property (nonatomic, weak) IBOutlet UILabel *lineLabel;</div><div class="line">@end</div><div class="line"></div><div class="line">// UYLTextCell.m</div><div class="line">#import &quot;UYLTextCell.h&quot;</div><div class="line">@implementation UYLTextCell</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在storyboard中设置这个类并将storyboard中的两个Label连接到两个IBOutlet中，同时设置它（uitableViewCell）的identifier：</p>
<p><img src="http://useyourloaf.com/assets/images/2014/2014-02-12-002.png" alt="图片8"></p>
<p>###设置TableView的DataSource</p>
<p>创建私有的priviate原型在VC中来保存我们的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface UYLTableViewController ()</div><div class="line">@property (nonatomic, strong) NSArray *sourceData;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这些内容保存在名叫：SourceData.plist的plist文件中，当调用sourceData的getter方法的时候，这将被导入到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)sourceData</div><div class="line">&#123;</div><div class="line">  if (!_sourceData)</div><div class="line">  &#123;</div><div class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;SourceData&quot; ofType:@&quot;plist&quot;];</div><div class="line">    _sourceData = [NSArray arrayWithContentsOfFile:filePath];</div><div class="line">  &#125;</div><div class="line">  return _sourceData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个tableViewController必须强制性实现2个UITableViewDataSource的方法，第一个返回section中的行数，这里我们返回sourceData这个数组的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">  return [self.sourceData count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二个方法是返回TableView的Cell从一个特殊的地方（译者注：如果没有生成则从内存池中，否则创建）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:UYLCellIdentifier forIndexPath:indexPath];</div><div class="line">  [self configureCell:cell forRowAtIndexPath:indexPath];</div><div class="line">  return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面的UYLCellIdentifier变量是一个静态NSString类，这是为了匹配storyboard中我们设置的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static NSString *UYLCellIdentifier = @&quot;UYLTextCell&quot;;</div></pre></td></tr></table></figure>
<p>configureCell方法将会设置cell的内容，你将会明白为什么这是一个好的方法来将代码放在单独的较短的方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)configureCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">  if ([cell isKindOfClass:[UYLTextCell class]])</div><div class="line">  &#123;</div><div class="line">    UYLTextCell *textCell = (UYLTextCell *)cell;</div><div class="line">    textCell.numberLabel.text = [NSString stringWithFormat:@&quot;Line %ld&quot;,(long)indexPath.row+1];</div><div class="line">    textCell.numberLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleCaption1];</div><div class="line">    textCell.lineLabel.text = [self.sourceData objectAtIndex:indexPath.row];</div><div class="line">    textCell.lineLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我们设置了两个Label的字体，万一用户想要修改他们的字体大小。</p>
<p>###处理动态文本的变化<br>tableView应该在用户改变字体大小之后就被重新加载。我们将在ViewDidLoad中将ViewController设置为一个观察者（observer）来观察UIContentSizeCategoryDidChangeNotification消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  [[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">           selector:@selector(didChangePreferredContentSize:)</div><div class="line">               name:UIContentSizeCategoryDidChangeNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc</div><div class="line">&#123;</div><div class="line">  [[NSNotificationCenter defaultCenter] removeObserver:self</div><div class="line">           name:UIContentSizeCategoryDidChangeNotification</div><div class="line">         object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didChangePreferredContentSize:(NSNotification *)notification</div><div class="line">&#123;</div><div class="line">  [self.tableView reloadData];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###计算Cell的高度<br>每一行的行高，我们需要使用<code>tableView:heightForRowAtIndexPath</code>方法。然而当这个方法被调用的时候，我们还没设置单元格的内容，所以很难设置他的高度。正如前面所提到的解决cell没有被加载但是应该调用他的布局，从而确定出他所需要的高度。所以我们增加了UYLTextCell来保存原型Cell的相关内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface UYLTableViewController ()</div><div class="line">...</div><div class="line">@property (nonatomic, strong) UYLTextCell *prototypeCell;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个Cell原型将在getter方法中请求tableView使用入队一个新的Cell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (UYLTextCell *)prototypeCell</div><div class="line">&#123;</div><div class="line">  if (!_prototypeCell)</div><div class="line">  &#123;</div><div class="line">    _prototypeCell = [self.tableView dequeueReusableCellWithIdentifier:UYLCellIdentifier];</div><div class="line">  &#125;</div><div class="line">  return _prototypeCell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整的delegate来计算每一行的高度方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">  [self configureCell:self.prototypeCell forRowAtIndexPath:indexPath];</div><div class="line">  [self.prototypeCell layoutIfNeeded];</div><div class="line"></div><div class="line">  CGSize size = [self.prototypeCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];</div><div class="line">  return size.height+1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一些内容提要：</p>
<ul>
<li>使用<code>configureCell</code>方法来根据内容配置cell，从而得到对应的行。就像<code>tableView:cellForRowAtIndexPath:</code>方法一样在cell显示之前配置。</li>
<li>调用layoutIfNeed来立即布局cell</li>
<li>调用<code>systemLayoutSizeFittingSize</code>方法来获得内容的最小的大小，从而创建合适的约束。（UILayoutFittingCompressedSize）</li>
<li>记得为了cell的分割线增加一个点大小。</li>
</ul>
<p>###估计cell高度<br>当我们在前面的实例工程中正确的设置tableViewCell的大小的时候，这仍旧有一个大的问题存在，那就是tableView的重载。为了在真机调试中找到这个问题，我们在后台改变了修改了文字内容的大小。在我的测试设备上，这彻底阻挡了用户的界面，浙江话费几秒钟来重新计算2000行的文字。这里有一个解决方法在iOS7中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">  return UITableViewAutomaticDimension;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法将快速的返回一个你所需要估计的cell的高度。因为这个方法是快速估计，所以不需要太多时间。产生一个准确的估计也可以根据不同文本的大小来进行动态的选择。</p>
<p>如果你无法正确的估计文本大小，同时想要不让用户察觉到你的表格正在被刷星，那就返回UITableViewAutomaticDimension这个系统默认值。</p>
<h3 id="问题与设备方向变化（2014年3月更新）"><a href="#问题与设备方向变化（2014年3月更新）" class="headerlink" title="问题与设备方向变化（2014年3月更新）"></a>问题与设备方向变化（2014年3月更新）</h3><p>正如评论中所指出的（对于提出的人我很感激。），这里有一个问题会造成返回错误的高度，当用户设备放下发生改变，这个问题的解决方法可以参考<a href="https://github.com/smileyborg" target="_blank" rel="external">smileyborg</a>的<a href="https://github.com/smileyborg/UIView-AutoLayout" target="_blank" rel="external">Github工程</a>。同时这个<a href="https://github.com/erf/AutoSizeTableCell" target="_blank" rel="external">Github的工程</a>也指出了我的问题，解决方法是先确保cell的宽度设置为原图标的宽度，再计算高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">  [self configureCell:self.prototypeCell forRowAtIndexPath:indexPath];</div><div class="line"></div><div class="line">  self.prototypeCell.bounds = CGRectMake(0.0f, 0.0f, CGRectGetWidth(self.tableView.bounds), CGRectGetHeight(self.prototypeCell.bounds));</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二我们需要调用layoutSubView在我们自定义的cell类中来设置多行Label中我们想要的最大宽度。官方文档中的<code>preferredMaxLayoutWidth</code>提供了这些细节。</p>
<blockquote>
<p>这个属性将会影响label的大小当设置的余数被应用的时候。在显示的时候，如果内容超过它的范围，那么额外的内容将会变成一行或者多行，因此会增加label的高度。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// UYLTextCell.m</div><div class="line">- (void)layoutSubviews</div><div class="line">&#123;</div><div class="line">  [super layoutSubviews];</div><div class="line">  [self.contentView layoutIfNeeded];</div><div class="line">  self.lineLabel.preferredMaxLayoutWidth = CGRectGetWidth(self.lineLabel.frame);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###写在最后<br>这是一篇长文章，我希望对你有用，如果想要代码你可以在<a href="https://github.com/kharrison/CodeExamples" target="_blank" rel="external">github</a>上找到</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
