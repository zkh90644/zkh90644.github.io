<!doctype html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/25/下载iOS模拟器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/25/下载iOS模拟器/" itemprop="url">下载iOS模拟器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-25T11:52:59+08:00">
                2016-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS 开发的小伙伴肯定经常会碰到需要使用不同的 iOS 模拟器进行版本的检测，但是直接从 Xcode 下载的话，有特别慢，这里就给大家带来如果不从 Xcode 进行 iOS simulator 的下载。</p>
<p>本文内容翻译自：<a href="http://stackoverflow.com/questions/29058229/download-xcode-simulator-directly" target="_blank" rel="external">点击跳转</a></p>
<ol>
<li>打开 Xcode，打开 preference，选择 Download 的按钮。</li>
<li>使用 Spotlight 或者 Alfred，输入 consle(中文为终端，并非terminal)。然后点击 console 里面的clear，清理之前显示的所有无用信息。</li>
<li>返回 Xcode 的 preference 选项，点击 你想要的 simulator开始已下载，然后点击<strong>取消</strong>按钮。</li>
<li>这个时候，再返回到 console 中，右上角的筛选器 filter 中输入 <code>cancel</code> 这个时候，在下面的界面里面会显示筛选出来一个 Xcode 进行过一个取消操作，然后点击这个选项，你可以在下面看到一个dmg文件的地址。</li>
<li>复制这个连接到浏览器，或者迅雷，你就可以直接通过下载了。</li>
<li>如果你不习惯用浏览器，你也可以直接用命令行 <code>curl [the url you copied] -O (the letter O, not a zero)</code> 直接使用 curl 进行下载。</li>
<li>最后讲这个文件放到 <code>~/Libary/Caches/com.apple.dt.Xcode/Downloads</code> 目录下面，然后删除所有后缀为<code>*.dvtdownloadableindex</code>（当然这不是必要的）。（译者附：如果没有downloads目录的话，可以自己创建，然后将下载好的内容<strong>复制</strong>到里面，为了防止出现无法加载资源，Xcode自动删除文档，如果还是不行，就点击下载按钮后，再暂停，然后放进去）</li>
<li>在 Xcode 中，再次在下载选项中点击开始下载对应Simulator按钮。再次进行下载，他就或提醒你你已经下载好并安装好了。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/16/chrome应用商店添加时总出现NETWORK-FAILED/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/16/chrome应用商店添加时总出现NETWORK-FAILED/" itemprop="url">chrome应用商店添加时总出现NETWORK_FAILED</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-16T20:36:40+08:00">
                2016-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tip/" itemprop="url" rel="index">
                    <span itemprop="name">tip</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Google中的应用商店使用的扩展安装的网址是另一套域名：*.googleusercontent.com</p>
<p>所以在proxy中添加<code>DOMAIN-KEYWORD,googleusercontent,Proxy,force-remote-dns</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/13/[译] Swift 3.0中不安全的世界 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/13/[译] Swift 3.0中不安全的世界 /" itemprop="url">Swift 3.0中不安全的世界</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-13T12:41:50+08:00">
                2016-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://technology.meronapps.com/2016/09/27/Swift-3-0-unsafe-world-2/?utm_source=Swift_Developments&amp;utm_medium=email&amp;utm_campaign=Swift_Developments_Issue_58" target="_blank" rel="external">原文链接</a></p>
<p>就像大多数现在的变成语言一样，在 Swfit 中你就像生活在一个幸福的世界中，这里的内存被额外的部分所管理，而像这样的内存管理语言的编译和运行要么就像 Swift 一样，要么他运行的好坏取决于他的垃圾回收机制。而这些我们所提到的这些隐藏在编程语言中的，你不必要去或者很少的情况下你需要去思考这些问题。</p>
<p>然而由于 Swift 的多样性的特点，你可能需要调用一个危险的 C 的 Api 比如说 OpenGL 或者 POSIX 中的函数，在这些情况下你可能需要处理一些让我们头疼的情况。没错，我说的就是指针和手动在堆中申请内存空间。</p>
<p>在 Swift 3.0 以前，Swift 的不安全的 API 有点混乱，你可以通过好几个方法来达到相同的结果，但是那只是你从 stackoverflow 上复制、粘贴来的，但是你没有彻底的理解真正发生了什么。在 Swift 3.0 中所有事物都发生了改变，而且他变得更容易理解。</p>
<p>在这篇文章中，我不会告诉你如何将代码从 Swift 2.x 迁移到 Swift  3.0。反而我将会告诉你这些事情在 Swift 3.0 中如何工作，因为通常造成不安全的引用的主要原因是与 C 的底层 API 的交互。</p>
<p>让我们从最简单的操作开始——开辟内存空间来存储一个整型变量。</p>
<p>在 C 中，你将会写下下面这样的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">*a = <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"a's value: %d"</span>,*a)</div><div class="line"></div><div class="line"><span class="built_in">free</span>(a)</div></pre></td></tr></table></figure>
<p>而这在 Swift 在这么实现的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">1</span>)</div><div class="line">a.pointee = <span class="number">42</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"a's value: <span class="subst">\(a.pointee)</span>"</span>) <span class="comment">//42</span></div><div class="line"></div><div class="line">a.deallocate(capacity:<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>第一类我们所看到的是 Swift 中的 <code>UnsafeMutablePointer&lt;T&gt;</code> ,这普通的结构体相当于一个 T 的指针，正如你所示的，他有一个静态函数， <code>allocate</code> 将会开辟需要的内存空间。</p>
<p>正如你所想的，这个 <code>UnsafeMutablePointer</code> 还有一个变形—— <code>UnsafePointer</code> ，这个类型不允许你修改指针的值，此外不可修改的 <code>UnsafePointer</code> 甚至没有 <code>allocate</code> 方法。</p>
<p>在 Swift 中，你还有另外一个方法来创建一个 <code>Unsafe[Mutable]Pointer</code> 方法，那就是使用 <code>&amp;</code> 操作。当传一个 block 或者函数，你可以使用一个 <code>&amp;</code> 来传入一个指针。让我们来看下面这个例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(pointer:UnsafePointer&lt;Int&gt;)</span></span>&#123;</div><div class="line">  <span class="built_in">print</span>(<span class="string">"param value is:<span class="subst">\(pointer.pointee)</span>"</span>)	<span class="comment">//42</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">42</span></div><div class="line">receive(pointer: &amp;a)</div></pre></td></tr></table></figure>
<p><code>&amp;</code> 操作需要一个 <code>var</code> 变量，但是这个将会提供给你你所需要解决的各种情况。比如说，你可以使用可修改的引用（mutable reference），甚至修改它，比如说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(mutablePointer:UnsafeMutablePointer&lt;Int&gt;)</span></span>&#123;</div><div class="line">  mutablePointer.pointee *= <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">42</span></div><div class="line">receive(mutablePointer:&amp;a)</div><div class="line"><span class="built_in">print</span>(<span class="string">"A's value has changed in the function:<span class="subst">\(a)</span>"</span>)	<span class="comment">//84</span></div></pre></td></tr></table></figure>
<p>这个例子和前面那个例子有重要的区别。在前面的例子中，我们需要手动开辟内存空间（我们需要在创建好后手动分配内存空间），同时在这个简单的例子中的函数中，我们快速的创建了一个指向内存的指针。明显的，管理内存并且使用指针指向他是2个不同的话题，在接下来的例子中，我们将会聊一聊如何管理内存空间。</p>
<p>但是我们如何在Swift中如何在不创建一个函数的情况下，调用指针。为了达到这种目的，我们需要使用 <code>withUnsafeMutablePointer</code> ，他将会调用一个 Swift 的引用类型和一个有参数的 block ，让我们来看看下面这个例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span></div><div class="line"><span class="built_in">withUnsafeMutablePointer</span>(to: &amp;a)&#123; $<span class="number">0</span>.pointee *= <span class="number">2</span>&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"a's value is: <span class="subst">\(a)</span>"</span>) <span class="comment">//84</span></div></pre></td></tr></table></figure>
<p>现在我们知道了这个方法，现在我们调用 C 中那些有指针的 API ，让我们看来看下下面这个 <strong>POSIX</strong> 的打开读取路径并获取其中内容的当前地址的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dirEnt: <span class="type">UnsafeMutablePointer</span>&lt;dirent&gt;?</div><div class="line"><span class="keyword">var</span> dp:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Dir</span>&gt;?</div><div class="line"></div><div class="line"><span class="keyword">let</span> data = <span class="string">"."</span>.data(using:ascii)</div><div class="line">data?.withUnsafeBytes(&#123;(ptr:<span class="type">UnsafePointer</span>&lt;<span class="type">Int8</span>&gt;) <span class="keyword">in</span></div><div class="line">	dp = opendir(ptr)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">repeat</span>&#123;</div><div class="line">  dirEnt = readdir(dp)</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> dir = dirEnt&#123;</div><div class="line">    <span class="built_in">withUnsafePointer</span>(to:&amp;dir.pointee.d_name,&#123; ptr <span class="keyword">in</span></div><div class="line">      <span class="keyword">let</span> ptrStr = unsafeBitCase(ptr,to:<span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;.<span class="keyword">self</span>)</div><div class="line">      <span class="keyword">let</span> name = <span class="type">String</span>(cString:ptrStr)</div><div class="line">      <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>"</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span> dirEnt != <span class="literal">nil</span></div></pre></td></tr></table></figure>
<p><strong>指针转换</strong></p>
<p>当处理 C 的 API 的时候，你有时候需要将指向结构体的指针转换为不同的结构体。对于 C 的 API 的处理很简单（同时也是十分危险并且容易出现报错）的，就像你在 Swift 中所看到的，所有指针的类型是被固定的，这意味着一个 <code>UnsafePointer&lt;Int&gt;</code> 的指针不能再用在需要 <code>UnsafePointer&lt;UInt8&gt;</code> 的地方，这使得能够更好的编写出更加安全的代码，但是同样意味着你不能在你需要的时候随意转换指针类型。比如说 socket 中的 <code>bind()</code> 方法比如说这些情况下，我们将会使用 <code>withMemoryRebound</code> 这个我们用来将一个指针类型转换为另一个指针类型的方法。让我们来看看我们是如何使用角色转换，在 <code>bind</code> 函数中当你创建一个 <code>sockaddr_in</code> 结构体转换为 <code>sockaddr</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addrIn = sockaddr_in()</div><div class="line"><span class="comment">// Fill sockaddr_in fields</span></div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;addrIn) &#123; ptr <span class="keyword">in</span></div><div class="line">    ptr.withMemoryRebound(to: sockaddr.<span class="keyword">self</span>, capacity: <span class="number">1</span>, &#123; ptrSockAddr <span class="keyword">in</span></div><div class="line">        bind(socketFd, <span class="type">UnsafePointer</span>(ptrSockAddr), socklen_t(<span class="type">MemoryLayout</span>&lt;sockaddr&gt;.size))</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个一个用来转变指针类型的特别的方法，一些 C 的 API 需要传一个 <code>void*</code> 指针。在 Swift 3.0 以前，你可能需要使用 <code>UnsafePointer&lt;Void&gt;</code> 。然而在3.0中有一个新的类型来处理这些指针： <code>UnsafeRawPointer</code> 。这个结构体和不同的结构体不同，所以这意味着他不会将其中的信息绑定到任何指定的类型中，这另我们的编码过程变得很简单。为了创建一个 <code>UnsafeRawPointer</code> 指针，我们只需要调用它的创建函数来包裹我们所需要的那个指针。如果我们想要用另外的方法，来将这个 UsafeRawPointer 的指针转化为其他类型的指针的时候，我们需要使用 <code>withMemoryRebound</code> 的上一个版本的方法，在这里他叫做 <code>assumingMemoryBound</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> intPtr = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">1</span>)</div><div class="line"><span class="keyword">let</span> voidPtr = <span class="type">UnsafeRawPointer</span>(intPtr)</div><div class="line"><span class="keyword">let</span> intPtrAgain = voidPtr.assumingMemoryBound(to: <span class="type">Int</span>.<span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<p><strong>数组指针</strong></p>
<p>到这里，我们我们已经学会了一些指针的基本使用方法，同时你可以处理大多数的 C 的 API 调用。然而指针使用的地方还有很多，比如说遍历内存块，这对于程序员来说是我们可以获得很多重要信息。在 Swift 中我们有一些方法来做这些事情，比如说 UnsafePointer 有提供了一个方法 <code>advanced(by:)</code> 来遍历内存，这个方法返回了另一个 UnsafePointer ，这样我们就可以读写那个内存区域里面的内容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> size = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> a = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: size)</div><div class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</div><div class="line">    a.advanced(by: idx).pointee = idx</div><div class="line">&#125;</div><div class="line">a.deallocate(capacity: size)</div></pre></td></tr></table></figure>
<p>另外， Swift 还有一个 <code>UnsafeBufferPointer</code> 的结构体来更方便的实现这个需求。这个结构体是一个Swift数组和指针的桥梁。如果我们使用 <code>UnsafePointer</code> 来作为变量从而调用创建函数创建一个 <code>UnsafeBufferPointer</code> ，我们将能够使用大多数的Swift原生的数组（Array）方法，因为 <code>UnsafeBufferPointer</code> 遵守并实现了 <code>Collections</code> ， <code>Indexable</code> 和 <code>RandomAccessCollection</code> 协议。所以我们可以像这样遍历内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Using a and size from previous code</span></div><div class="line"><span class="keyword">var</span> b = <span class="type">UnsafeBufferPointer</span>(start: a, <span class="built_in">count</span>: size)</div><div class="line">b.forEach(&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span> <span class="comment">// Prints 0 to 9 that we fill previously</span></div><div class="line">)&#125;)</div></pre></td></tr></table></figure>
<p>当我们提到 <code>UnsafeBufferPointer</code> 的是一个Swift中数组的桥梁的时候，这也意味着我们很容易使用 <code>UnsafeBufferPointer</code> 来调用一个已经存在的数组，比如说下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">a.withUnsafeBufferPointer(&#123; ptr <span class="keyword">in</span></div><div class="line">    ptr.forEach(&#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;) <span class="comment">// 1, 2, 3...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>内存管理带来的危害</strong></p>
<p>我们已经看到了很多方法来引用原始内存，但是我们不能忘记我们正在进入一个危险区域。可能重复 <code>Unsafe</code> 单词可能会提醒我们要小心的使用它们。然而我们我们是使用 <code>unsafe</code> 引用来混合两个世界（不需要内存管理和手动内存管理）。让我们来看看他在我们灵活使用中所带来的危害。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> collectionPtr: <span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Int</span>&gt;?</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">duplicateElements</span><span class="params">(inArray: UnsafeMutableBufferPointer&lt;Int&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;inArray.<span class="built_in">count</span> &#123;</div><div class="line">        inArray[i] *= <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">repeat</span> &#123;</div><div class="line">    <span class="keyword">var</span> collection = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">    collection.withUnsafeMutableBufferPointer(&#123; collectionPtr = $<span class="number">0</span> &#125;)</div><div class="line">&#125; <span class="keyword">while</span> <span class="literal">false</span></div><div class="line"></div><div class="line">duplicateElements(inArray: collectionPtr!) <span class="comment">// Crash due to EXC_BAD_ACCESS</span></div></pre></td></tr></table></figure>
<p>虽然这个简单的例子我们不会真正的碰到，但是实际在快速创建变量的过程中我们会碰到和他类似但是比他更加复杂的代码。在这里， <code>collection</code> 在一个 block 中被创建，同时在 block 结束后引用被释放。我们有意的在调用 <code>collection</code> 后将引用保存在了 <code>collectoinPtr</code> 中，然后在原始的 <code>collection</code> 不在存在后继续调用，所以程序在调用 <code>duplicateElements(inArray:)</code> 后崩溃了，如果我们想要使用指针来快速创建变量，我们需要确定这些变量能够在我们需要使用它们的时候可用。注意ARC将在每个变量离开他的作用于的时候为每个变量添加 <em>release</em> 方法，如果这个变量没有被强引用的话，他就会被释放。</p>
<p>一个解决方法是不适用 Swift 的内存管理方法而是我们自己手动开辟内存空间，就像我们文章中所提到的那些简单的代码一样，这就解决了访问无效引用的问题，但是这引入了另一个问题。如果我们没有手动释放内存，那么就会存在内存泄漏问题。</p>
<p><strong>使用 bitPattern 来修改指针的值</strong></p>
<p>为了更好地完成这篇文章，在这我将介绍一些 Swift 中指针的用法。 第一个就是在使用C的API的时候使用 <code>void*</code> 方法而不是使用内存地址。通常这会发生在一个函数接受不同类型的参数，并简单的将参数打包成 void* 类型，就像下面这个例子一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void generic_function(int value_type, void* value);</div><div class="line"></div><div class="line">generic_function(<span class="type">VALUE_TYPE_INT</span>, (void *)<span class="number">2</span>);</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_data</span> <span class="title">data</span>;</span></div><div class="line"><span class="title">generic_function</span>(<span class="title">VALUE_TYPE_STRUCT</span>, (<span class="title">void</span> *)&amp;<span class="title">data</span>);</div></pre></td></tr></table></figure>
<p>如果我们想要在 Swift 中调用第一个函数，我们需要使用特别的构造函数，这会创建一个特殊的地址的。所有这些函数将不会改变允许你改变内存地址中变量的值，所以我们将会在这种情况下使用 <code>UnsafePointer(bitPattern:)</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">generic_function(<span class="type">VALUE_TYPE_INT</span>, <span class="type">UnsafeRawPointer</span>(bitPattern: <span class="number">2</span>))</div><div class="line"><span class="keyword">var</span> data = function_data()</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;data, &#123; generic_function(<span class="type">VALUE_TYPE_STRUCT</span>, <span class="type">UnsafeRawPointer</span>($<span class="number">0</span>)) &#125; )</div></pre></td></tr></table></figure>
<p><strong>透明指针</strong></p>
<p>在这篇文章的最后我想说的就是如何使用 Swift 中的透明指针。在C的 API 中我们经常会调用用户数据，而用户的数据将会成为一个 <code>void*</code> 指针，该用户数据将是一个 void * 指针，他将保存在一个任意内存中。一个通用的使用方法是当处理函数并设置回调方法的时候，事件将会被调用。在这种情况下，传入一个引用到一个 Swift 对象中，然后我们就可以在 C 的回调函数中调用指针的方法。</p>
<p>我们能够使用 <code>UnsafeRawPointer</code> 就像我们曾在这篇文章中的其他例子中所看到的。然而正如我们所看到的，这些调用在内存管理中有一定的问题，当我们传入一个指针到 C 中来指向一个我们没有 retain 的变量的时候，这个对象将被释放，同时这个程序将会崩溃。</p>
<p> Swift 有一个实用的方法来根据我们是否真的需要，从而决定指向这个对象的指针是否进行 retain 。这就是 <code>Unmanaged</code> 结构体的一个静态函数。使用 <code>passRetained()</code> 我们将会创建一个被 retained 的指向这个对象的指针，那么我们就能保证当他在 C 中被调用的时候他仍旧在那。当这个对象已经在回调函数中被 retianed 的时候我们可以使用 <code>passUnretained()</code> 。这两个方法将会产生 <code>Unmanaged</code> 的实例变量，这个实力变量将会通过调用 <code>toOpaque()</code> 方法转换为 <code>UnsafeRawPointer</code></p>
<p>在另一方面我们可以将 <code>UnsafeRawPointer</code> 通过相反的 API <code>fromOpaque()</code> 和 <code>takeRetained()</code> 转换为一个类或者结构体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void set_callback(void (*functionPtr)(void*), void* userData));</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CallbackUserData</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Hello world!"</span> ) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">callback</span><span class="params">(userData: UnsafeMutableRawPointer)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> callbackUserData = <span class="type">Unmanaged</span>.fromOpaque(userData).takeRetainedValue()</div><div class="line"></div><div class="line">    callbackUserData.sayHello() <span class="comment">// "Hello world!"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> userData = <span class="type">CallbackUserData</span>()</div><div class="line"><span class="keyword">let</span> reference = <span class="type">Unmanaged</span>.passRetained(userData).toOpaque()</div><div class="line">set_callback(callback, reference)</div></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>正如你所看到的，调用 C 的代码在 Swift 是可行的，同时知道了有这些方法使得我们不需要用大量的代码就能实现我们想要的效果。不安全和非管理的 API 在本文中被大量的提到，但是我希望这是一个很好的进行深入了解的机会，从而你可以对他感兴趣或者能够真正的使用它。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/21/iOS core animated/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/21/iOS core animated/" itemprop="url">iOS Core Animation初学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-21T11:30:50+08:00">
                2016-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>动画</p>
<ul>
<li>直接动画</li>
</ul>
</li>
</ol>
<ul>
<li><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, delay: <span class="number">0.5</span>, options: [], animations: &#123;</div><div class="line">    &#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>spring弹簧效果</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIView.animateWithDuration(0.33, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.0, options: [], animations: &#123;</div><div class="line">    //code</div><div class="line">    &#125;, completion: &#123;_ in</div><div class="line">    //code</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p>使用关键帧</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 0.25, animations: &#123;</div><div class="line">self.planeImage.center.x += 80.0</div><div class="line">self.planeImage.center.y -= 10.0 &#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>通过<code>CGAffineTransformIdentity</code>来将形变变回变形前的状态</p>
</li>
<li><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">CGAffineTransformConcat</span>(</div><div class="line"><span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.1</span>), <span class="comment">//缩放</span></div><div class="line"><span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">0.0</span>, -auxLabelOffset)) &#125; <span class="comment">//位移</span></div><div class="line"><span class="comment">//绑定多个形变</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>4.<br>   <code>CGAffineTransformMakeRotation</code>来创建旋转形变</p>
<ol>
<li><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.0</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</div><div class="line"><span class="keyword">self</span>.planeImage.center.x += <span class="number">80.0</span></div><div class="line"><span class="keyword">self</span>.planeImage.center.y -= <span class="number">10.0</span> &#125;)</div><div class="line"><span class="comment">//通过添加关键帧来设置每个时间，上面的第一个参数为在前面关键帧动画中的百分比</span></div></pre></td></tr></table></figure>
</li>
<li><p>可以修改layer的参数来实现静态动画。</p>
</li>
<li><p>在使用autolayout的时候，可以通过设置对应的参数后使用layoutIfNeed来进行创建动画</p>
</li>
<li><p>通过设置<code>constraint.active = false</code>来设置对应的约束是否生效</p>
</li>
<li><p>通过创建CAAnimate对象来创建对应的动画，然后将对应的layer使用<code>setAnimation</code>来设置对应的内容，<code>key</code>为后期删除或者修改的时候来设置对应的动画。</p>
</li>
<li><p>通过通过设置CABasicAnimated的<code>fromValue</code>和<code>toValue</code>还有<code>duration</code>来设置动画效果。</p>
</li>
<li><p>通过CABasicAnimation的keyPath来确定修改的属性。</p>
</li>
<li><p>通过设置beginTime来设置开始的时间一般为(CACurrentMediaTime()+doubleNmber)</p>
</li>
<li><p><code>fillMode</code>用来设置是否在动画谦和后来进行显示。默认为none，一般设置为<code>KCAfillModeBoth</code>（这样动画前和动画后的操作都不会出现）</p>
</li>
<li><p>使用Animatation的实际操作是，隐藏原有对象，然后创建新图片对象，然后操作图片对象，等到图片对象运动完，然后继续显示原对象。（为了不显示原对象，可以设置<code>removeOnCompletion = false</code>来进行设置，但是无法操作。）</p>
</li>
<li><p>使用delegate来确定animation开始和结束的时间，同时通过KVC来进行设置对应的参数。</p>
</li>
<li><p>通过<code>layer.removeAnimationForKey</code>来删除对应的Animation</p>
</li>
<li><p>通过AnimationGroup来异步加载所有动画效果，然后通过将CABasicAnimation加入到group中，从而使得动画异步，通过timingFunction来设置动画的速度。</p>
</li>
<li><p>通过CABasicAnimation的repeatCount来设置对应的重复次数，或者通过autoreverses = true来使得不断重复</p>
</li>
<li><p>通过设置speed来调整原来的速度倍速。2为2倍，由于speed的存在，duration的实际时间为除以speed后的时间</p>
</li>
<li><p>通过设置layer.speed后，实际上的速度是animation.Speed * view.layer.speed的速度，而且layer的speed作用于他的子layer</p>
</li>
<li><p>UIKit(UIView.animationWithDuration)相对Core Animation更加强制。Core Animation可以设置更多参数，但是不能设置duration，duration会自行计算。</p>
</li>
<li><p>CASpringAnimation如果设置了duration，如果duration小于实际时长的话，那么当到达duration的话，就会直接跳到结束。可以用duration = pulse.settlingDuration 来进行设置</p>
</li>
<li><p>CASprintAnimation常见参数</p>
</li>
</ol>
<ul>
<li>damping为阻尼，默认为10</li>
<li>mass为，默认为1<ul>
<li>stiffness，默认为100</li>
<li>initialivelocity，默认为0</li>
</ul>
</li>
</ul>
<ol>
<li><p>使用CAKeyframeAnimation来代替animationWithKeyframe，通过values来设置每一帧的值，通过keyTimes来设置对应的转动的百分比时间。</p>
</li>
<li><p>通过NSValue(CGPoint())来将CGPoint转化为value，如果需要转换的为数组，那么使用map{NSValue(CGPoint:$0)}</p>
</li>
<li><p>通过对layer进行添加animation来发生形变，同时通过UIView.durationWithAnimation中的complete，从而更加方便的进行回调。从而不需要调用delegate</p>
</li>
<li><p>通过CAGradientLayer来创建渐变图层，左上为（0，0）右下为（1，1），color属性设置颜色，locations属性设置颜色位置</p>
</li>
<li><p>通过layer.mask =  CALayer()，来设置对应的遮罩层，从而显示图像。</p>
</li>
<li><p>设置UIGraphicsBeginImageContextWithOptions中的scale为0，从而使得对应的图像分辨率为显示器的分辨率</p>
</li>
<li><p>通过使用CAShapeLayer来创建纯线的描绘，设置start和end，从而显示位置，为百分比。LineDashPattern的数组来设置哪几块绘制。</p>
</li>
<li><p>kCAAnimationDiscrete 是一帧一帧，每一帧都要代码计算得到，而kCAAnimationPaced则是平滑的动画效果。</p>
</li>
<li><p>对于重复的动画，使用CAReplicatorLayer()，然后将需要重复的内容加入其中，同时设置instanceCount(重复个数),instanceTransform(重复的位置),instanceDelay(重复内容的动画延迟时间)</p>
</li>
<li><p>通过CATransform3DIdentity，从而获得对应的齐次矩阵，然后设置透视角度，identity.m34 = -1.0/1000,一般为250~2000，小于250，因为太大而形变，大于2000，基本平行，则没感觉。然后通过CATransform3dMakeXXXX这类函数进行形变，对矩阵进行设置，从而变形对应的对象。</p>
</li>
<li><p>设置layer的sublayerTransform属性，从而使得所有子layer都遵守这个透视图。</p>
</li>
<li><p>对于layer的animation的操作，不仅仅要给予layer的动画效果，还要设置最后的transform后的效果。</p>
</li>
<li><p>对于粒子效果，可以通过创建CAEmitterLayer来创建</p>
</li>
</ol>
<ul>
<li>emitterShape:设置粒子效果（发射方向</li>
<li>emitterPosition：喷射点<ul>
<li>emitterSize：喷射区域大小</li>
<li>emitterCells：粒子种类</li>
</ul>
</li>
</ul>
<ol>
<li>CAEmitterCell来设置对应的粒子</li>
</ol>
<ul>
<li>contents：图片样式</li>
<li>birthRate：每秒产生个数<ul>
<li>lifetime：每个生命周期</li>
<li>lifetimeRange：声明周期误差（正负）</li>
<li>yAcceleration：y轴加速度</li>
<li>xAcceleration：x轴加速度</li>
<li>velocity：初始速度</li>
<li>emissionLongitude：初始方向</li>
<li>velocityRange：速度误差值</li>
<li>emissionRange：方向误差值</li>
<li>redRange，greenRange，blueRange：红蓝绿的颜色类型</li>
<li>scale：缩放</li>
<li>scaleRange：缩放误差</li>
<li>scaleSpeed：缩放速度</li>
<li>alphaRange：透明度范围</li>
</ul>
</li>
</ul>
<ol>
<li><p>CGAffineTransformMakeScale(-1, 1)即将图片翻转</p>
</li>
<li><p>通过UIImageView.animationImages = [UIImages]来设置逐帧动画，animationDuration来设置动画时长,animationRepeatCount来设置重复次数，使用startAnimating来执行动画</p>
</li>
<li><p>UIViewController转换的方法：</p>
</li>
<li><p>首先创建对应的动画对象，遵守UIViewControllerAnimatedTransitioning协议</p>
<ol>
<li>在需要跳转的对应的VC上遵守UIViewControllerTransitioningDelegate协议</li>
<li>重写animationControllerForPresentedController方法，返回需要调用的动画对象，</li>
<li>在动画对象中transitionDuration，返回动画时间</li>
<li>在animateTransition设置动画效果。</li>
<li>基本思路是，fromVC刚开始被container所包裹（transitionContext)，一开始的时候，toVC不存在，这个时候需要创建，并将对应的VC加入到container中，在duration结束后，transitionContext.completeTransition(true)，从而告诉UIKit结束动画。</li>
</ol>
</li>
<li><p>UINavigationController跳转动画，</p>
</li>
<li><p>创建对应的动画对象，遵守UIViewControllerAnimatedTransitioning协议</p>
<ol>
<li>在需要跳转的对应的VC上遵守UINavigationControllerTransitioningDelegate协议</li>
<li>在navigationController方法总返回跳转对象transition，同时设置oepration方向（PUSH还是POP</li>
<li>动画对象中设置duration时长和设置的动画。根据不同的operation的方向来决定动画效果。</li>
<li>在animationTransition设置点动画效果</li>
<li>同UIViewController</li>
</ol>
</li>
<li><p>具有交互的跳转动画</p>
</li>
<li><p>动画对象继承UIPercentDrivenInteractiveTransition(不在使用继承NSObject)</p>
<ol>
<li><p>其余和上相同</p>
</li>
<li><p>根据手势的不同状态，比如说recgnizer.state调用updateInteractiveTransition(progress)//更新图像，让界面进行重绘</p>
<p>startInteractiveTransition(progress)//开始更新图像图像</p>
</li>
</ol>
</li>
<li><p><strong>kCAFillModeRemoved</strong> 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态<br><strong>kCAFillModeForwards</strong> 当动画结束后,layer会一直保持着动画最后的状态<br><strong>kCAFillModeBackwards</strong> 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态<br><strong>kCAFillModeBoth</strong> 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/22/深入了解iOS中的VC切换的传值方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/22/深入了解iOS中的VC切换的传值方式/" itemprop="url">深入了解iOS中VC切换的传值方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-22T08:28:00+08:00">
                2016-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于上次面试中有提到相关内容，所以这次我专门深入研究了iOS的几种方式：<br>首先把所有的传值方式都列出来，如果有遗漏，请指正</p>
<hr>
<p>首先列出iOS中使用的传值方式：</p>
<ol>
<li>init 传值（即在创建VC的时候就对响应的参数进行设置）</li>
<li>property 传值（即属性赋值）</li>
<li>Router 传值（这个在OC中被使用，因为作者没有写Swift版本，所以先开个坑，估计我会填坑）</li>
<li>Delegate 传值（通过协议和代理传值）</li>
<li>闭包（block）传值  （通过swift中的闭包，类似于OC中的block传值）</li>
<li>Notification 传值 （通过消息中心进行传值）</li>
<li>KVO 传值  （通过观察者模式进行传值）</li>
<li>AppDelegate 传值 通过Appdelegate进行传值</li>
<li>NSUserDefault 传值 通过NSUserDefault传值</li>
<li>通过static进行全局变量的存储，这里就不再进行演示</li>
</ol>
<p>基本上总结起来就是以上10种，接下来我会一种种介绍，同时会讲明传值方式中所遇到的坑。</p>
<p>本文中的所有代码已经放到github上，我会在文章最后加上github地址，所以在文章中只展示主要的代码。</p>
<h2 id="一、init-传值"><a href="#一、init-传值" class="headerlink" title="一、init 传值"></a>一、init 传值</h2><p>这个解释起来很简单，就是在VC对象init的时候，通过调用自定义的init函数，从而将所需要的参数传入对应的对象内。</p>
<p><strong>实现代码如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//源VC</div><div class="line">func jumpToNextVC() &#123;</div><div class="line">    let goal = TVGoalViewController.init(text: self.input.text!)</div><div class="line">    navigationController?.pushViewController(goal, animated: true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//目标VC</div><div class="line">convenience init(text:String) &#123;</div><div class="line">    self.init(nibName:nil, bundle:nil)</div><div class="line">    self.text.text = text</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，这种传值方式有着较高的耦合，对后期的维护有一定的影响，所以个人不建议。（虽然我在一开始写代码的时候很不要脸的这么干的~~）</p>
<h2 id="二、property-传值（即属性赋值）"><a href="#二、property-传值（即属性赋值）" class="headerlink" title="二、property 传值（即属性赋值）"></a>二、property 传值（即属性赋值）</h2><p>property传值就是通过在创建完VC后，对VC中的每个属性都单独复制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//源VC:</div><div class="line">func jumpToNextViewController() &#123;</div><div class="line">    let goal = TVGoal2ViewController()</div><div class="line"></div><div class="line">    goal.showlabel.text = self.input.text</div><div class="line"></div><div class="line">    self.navigationController?.pushViewController(goal, animated: true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优缺点：虽然相较上一种方式来说，解了耦合，但是因为要在原VC中进行赋值，所以需要目标VC中的相应属性设置为Public，这对于代码的安全性有一定的影响。</p>
<h2 id="三、Router-传值"><a href="#三、Router-传值" class="headerlink" title="三、Router 传值"></a>三、Router 传值</h2><p>这种方式在OC中有一定的用到，但是比较冷门，主要的方式通过一个单独的类来保存所有需要跳转的VC，同时将值保存在对应的params。从而通过类的函数对类进行转换，这个因为原作者只有OC版本，所以这里就不贴上OC代码，估计我会在接下来几天将这个函数移植到swift上。</p>
<p>优缺点：由于通过类来保存需要的内容，这样就解耦了，不过由于要引入第三方类，所以操作相对而言比较繁琐，而且需要学习第三方框架的函数，所以有一定的学习成本。</p>
<h3 id="四、Delegate-传值"><a href="#四、Delegate-传值" class="headerlink" title="四、Delegate 传值"></a>四、Delegate 传值</h3><p>这种方式在iOS开发中是比较常见的几种方法之一，而且苹果官方也大量的使用这个方法，比如说AppDelegate。同时在UITextField，UIScrollView等控件中也经常性的使用这种方法传值。</p>
<p>苹果官方对Delegate有以下的解释：</p>
<blockquote>
<p>Delegation is a simple and powerful pattern in which one object in a program 1 acts on behalf of, or in coordination with, another object. The delegating object keeps a reference to the other object—the delegate—and at the appropriate time sends a message to it. The message informs the delegate of an event that the delegating object is about to handle or has just handled. The delegate may respond to the message by updating the appearance or state of itself or other objects in the application, and in some cases it can return a value that affects how an impending event is handled. The main value of delegation is that it allows you to easily customize the behavior of several objects in one central object.</p>
</blockquote>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//原VC文件</div><div class="line">protocol LoginDelegate &#123;</div><div class="line">    func changeText(name:String)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TVLoginViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    @IBOutlet weak var label: UITextField!</div><div class="line">    @IBOutlet weak var loginButton: UIButton!</div><div class="line">    var delegate:LoginDelegate?</div><div class="line"></div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line"></div><div class="line">        self.loginButton.addTarget(self, action: #selector(clickLogin), forControlEvents: UIControlEvents.TouchUpInside)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func clickLogin() &#123;</div><div class="line">        self.delegate?.changeText(self.label.text!)</div><div class="line">        self.navigationController?.popViewControllerAnimated(true)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//目标VC文件</div><div class="line">class TVDelegateViewController: UIViewController,LoginDelegate&#123;</div><div class="line">    @IBOutlet weak var welcomeLabel: UILabel!</div><div class="line">    @IBOutlet weak var login: UIButton!</div><div class="line"></div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line"></div><div class="line">        login.addTarget(self, action: #selector(next), forControlEvents: UIControlEvents.TouchUpInside)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    func changeText(name: String) &#123;</div><div class="line">        self.welcomeLabel.text = &quot;欢迎回来：&quot;+name</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func next() &#123;</div><div class="line">        let goal = TVLoginViewController()</div><div class="line">        goal.delegate = self</div><div class="line">        self.navigationController?.pushViewController(goal, animated: true)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优缺点：个人来说，我比较看好delegate传值，因为他结构明显，清晰的语法定义，减少维护成本，较强的代码可读性。 同时减少代码的耦合性，使事件监听和事件处理相分离。 不需要创建第三方来监听事件和传输数据。 并且一个控制器可以实现多个代理，满足自定义开发需求，可选必选有较大的灵活性。但是由于需要创建协议，再进行编码，可能代码量比较大。</p>
<h2 id="五、闭包传值"><a href="#五、闭包传值" class="headerlink" title="五、闭包传值"></a>五、闭包传值</h2><p>闭包传值类似于oc中的block传值。而苹果官方对于Block的解释是这样的：</p>
<blockquote>
<p>A block is an anonymous inline collection of code, and sometimes also called a “closure”.<br>Blocks are a powerful C-language feature that is part of Cocoa application development. They are similar to “closures” and “lambdas” you may find in scripting and programming languages such as Ruby, Python, and Lisp. Although the syntax and storage details of blocks might at first glance seem cryptic, you’ll find that it’s actually quite easy to incorporate blocks into your projects’ code.</p>
</blockquote>
<p>这说明闭包在实际使用中有着较大的使用面，不仅仅在oc中，在ruby，python，lisp中均有使用。同时由于实现它所需要的代码量相对于delegate更少，所以很多人都喜欢用（不过我不太喜欢）。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//原VC文件：</div><div class="line">typealias returnClosure = (string:String)-&gt;Void</div><div class="line">...</div><div class="line">func login() &#123;</div><div class="line">    if closureValue != nil &#123;</div><div class="line">        closureValue!(string: self.input.text!)</div><div class="line">    &#125;</div><div class="line">    self.navigationController?.popViewControllerAnimated(true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//目标VC文件</div><div class="line">func myClosure(string:String) -&gt; Void &#123;</div><div class="line">    self.welcomeLabel.text = &quot;欢迎：&quot;+string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func jump() &#123;</div><div class="line">    let goal = TVLogin1ViewController()</div><div class="line">    goal.closureValue = myClosure</div><div class="line">    self.navigationController?.pushViewController(goal, animated: true)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="六、Notification传值"><a href="#六、Notification传值" class="headerlink" title="六、Notification传值"></a>六、Notification传值</h2><p>Notification也是和上面的Delegate一样，在iOS开发中经常使用，他通过使用设计模式中的观察者模式，不过当其中一个内容进行变化的时候，通过NotificationCenter来接受内容变化，从而告诉需要告诉的人，原值已经发生改变了。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//原VC文件：</div><div class="line">func logYouName() &#123;</div><div class="line">    let notific = NSNotification.init(name: &quot;loginNameNotification&quot;, object: self, userInfo: [&quot;name&quot;:name.text!])</div><div class="line"></div><div class="line">	NSNotificationCenter.defaultCenter().postNotification(notific)</div><div class="line"></div><div class="line">	self.navigationController?.popViewControllerAnimated(true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//目标VC文件：</div><div class="line">func next() &#123;</div><div class="line">    let goal = TVLogin2ViewController()</div><div class="line"></div><div class="line">    NSNotificationCenter.defaultCenter().addObserver(self, selector: #selector(loginName), name: &quot;loginNameNotification&quot;, object: goal)</div><div class="line"></div><div class="line">    self.navigationController?.pushViewController(goal, animated: true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func loginName(notification:NSNotification) &#123;</div><div class="line">    let dic = notification.userInfo</div><div class="line"></div><div class="line">    self.welcomeButton.text = &quot;欢迎:&quot;+(String)(dic![&quot;name&quot;]!)</div><div class="line">    NSNotificationCenter.defaultCenter().removeObserver(self)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优缺点：Notificatoin使用了设计模式中的观察者模式，这种模式的好处就是：使用简单，代码精简。同时解决了同时向多个对象监听相应的问题，当需要调用修改的内容的时候也十分方便。</p>
<h2 id="七、KVO-传值"><a href="#七、KVO-传值" class="headerlink" title="七、KVO 传值"></a>七、KVO 传值</h2><p>这种传值和Notification的传值方法想法上面基本一致，都是通过设计模式中的观察者模式来进行实现的。不过区别是，一般来说Notification是作为一个第三者的单例来进行实现，而KVO是直接通过一个对象来观察另一个对象的值是否发生改变，观察者本身和被观察者不一定是要VC，只要是继承了NSObject即可实现该方法。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//原来VC文件</div><div class="line">func login() &#123;</div><div class="line">    self.setValue(input.text, forKey: &quot;username&quot;)</div><div class="line">	self.navigationController?.popViewControllerAnimated(true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//目标VC文件：</div><div class="line">override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    loginButton.addTarget(self, action: #selector(login), forControlEvents: UIControlEvents.TouchUpInside)    </div><div class="line"></div><div class="line">    goal.addObserver(self, forKeyPath: &quot;username&quot;, options: [NSKeyValueObservingOptions.New,NSKeyValueObservingOptions.Old], context: nil)</div><div class="line">&#125;</div><div class="line"></div><div class="line">override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123;</div><div class="line">    if keyPath == &quot;username&quot; &#123;</div><div class="line">		self.welcomeLabel.text = &quot;欢迎&quot;+(String)((change!)[&quot;new&quot;]!)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优缺点：优缺点和Notification大相近庭，不过在这里面使用的时候有个坑，当你在input输入相应的文字内容的时候，你需要在点击log之后，将文本中的内容进行保存，因为观察者不会对UITextField中的内容进行观察，所以很有可能发生问题。（个人不建议使用这个方法来用来观察需要手动输入的变量）</p>
<h2 id="八、AppDelegate-传值"><a href="#八、AppDelegate-传值" class="headerlink" title="八、AppDelegate 传值"></a>八、AppDelegate 传值</h2><p>这个方法基于iOS App的实际创建方法，通过AppDelegate来唤起整个App，从而使得AppDelegate可以操控整个App，同时作为总控制，所有内部的类都能够通过UIApplication来获取Delegate，从而得到AppDelegate。所以可以通过他来进行值的传输。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//源VC文件</div><div class="line">func next()  &#123;</div><div class="line">    let next = TVGoal3ViewController()</div><div class="line"></div><div class="line">    let selfDelegate = UIApplication.sharedApplication().delegate as! AppDelegate</div><div class="line"></div><div class="line">    selfDelegate.storeString = self.input.text!</div><div class="line"></div><div class="line">    self.navigationController?.pushViewController(next, animated: true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//目标VC文件</div><div class="line">override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    let app = UIApplication.sharedApplication()</div><div class="line"></div><div class="line">    let selfDelegate = app.delegate as! AppDelegate</div><div class="line"></div><div class="line">    showLabel.text = selfDelegate.storeString</div><div class="line"></div><div class="line">    self.backButton.addTarget(self, action: #selector(goBack), forControlEvents: UIControlEvents.TouchUpInside)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优缺点：由于通过AppDelegate来实现，基本上内容都保存在AppDelegate中，所以调用起来方便，由于都保存在那里面，导致整个AppDelegate显得臃肿，不方便与以后的维护。</p>
<h2 id="九、NSUserDefault-传值"><a href="#九、NSUserDefault-传值" class="headerlink" title="九、NSUserDefault 传值"></a>九、NSUserDefault 传值</h2><p>苹果提供给开发者一个NSUserDefault这个系统变量，开发者可以通过这个来将内容保存到整个系统中，从而方便下一次的调用，这个和AppDelegate有异曲同工之妙。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//源文件NSUserDefaults.standardUserDefaults().setObject(self.input.text, forKey: &quot;store&quot;)</div><div class="line"></div><div class="line">//目标文件</div><div class="line">let userdefault = NSUserDefaults.standardUserDefaults()</div><div class="line">self.showLabel.text = (String)(userdefault.valueForKey(&quot;store&quot;)!)</div></pre></td></tr></table></figure>
<p>优缺点：主要和AppDelegate一样，不过因为是系统级的变量，所以他所给予我们的内存空间是有限的，不能存放太大的资料。（记得存储完同步下，方便以后继续使用）</p>
<h2 id="十、全局变量Static-传值"><a href="#十、全局变量Static-传值" class="headerlink" title="十、全局变量Static 传值"></a>十、全局变量Static 传值</h2><p>这个和一般语言中都一样，由于Static存在于全局存储区（静态存储区），只要程序不退出，那么就会一直保存起来。这样的一个好处就是你可以反复使用，但是由于不释放，所以如果量一大，容易发生内存不足~~所以不建议使用。</p>
<p>总结：以上就是所有10种iOS中的常见传值方式，他们各有各的优点，缺点，所以具体到底如何使用，还是需要开发者自己甄别。</p>
<p>最后贴上<a href="https://github.com/zkh90644/PassValueDemo" target="_blank" rel="external">Github地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/18/iOS内存管理机制及属性的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/18/iOS内存管理机制及属性的应用/" itemprop="url">iOS内存管理机制及属性的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-18T19:21:50+08:00">
                2016-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>对于OC的使用者来说，最会被问到的就是iOS开发中的内存管理。而只要涉及到内存管理，就肯定会涉及到property。而且在平常iOS开发的面试中，我们也经常会被问到相关的问题。所以这次就结合我所见到的和自己对于属性的理解来进行简述，希望对你们有帮助。</p>
</blockquote>
<p>在讲述属性前，我们需要对于iOS开发中的内存管理有一个初步的了解。</p>
<p>本文中的部分内容来源于：<a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="external">这里</a>和<a href="http://www.samirchen.com/ios-autorelease-pool/" target="_blank" rel="external">这里</a>还有部分来源于苹果官方文档。</p>
<h2 id="iOS开发中的内存使用情况"><a href="#iOS开发中的内存使用情况" class="headerlink" title="iOS开发中的内存使用情况"></a>iOS开发中的内存使用情况</h2><ul>
<li>栈（stack）：栈是编译器自动分配并释放，用来存放函数的参数，局部变量。</li>
<li>堆（heap）：堆一般是程序员自己分配和释放，如果我们在使用的过程中，没有释放，那么等到程序完全结束，系统将会对堆中的内容进行回收。一般开发中的alloc就是存放在堆中的</li>
<li>全局变量（静态变量）（static）：全局变量和静态变量是单独存放的，因为他们的声明周期和整个程序的生命周期一致。释放的时间是由整个程序结束后系统负责回收。</li>
<li>文字常量区：一般用来存放常量字符串，比如说<code>String *str = @&quot;hello world&quot;</code>,他的释放也和全局变量一致，在程序结束后进行释放。</li>
<li>程序代码区：用来存放函数的二进制内容的区域。</li>
</ul>
<p>他们之间的在内存中存放的关系如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="内存管理"></p>
<p>而在日常开发过程中，我们所遇到最多的也是最容易问到的就是<strong>堆</strong>和<strong>栈</strong>，可能有的人对于这两者还是很模糊，所以我再引用之前看到过的一段话来解释（由于很久以前看到了，已经忘记了出处，如果有人能够告诉我，我一定加上）：</p>
<p>内管管理就像做菜，而<strong>堆</strong>的使用就像我们下馆子，我们只要去酒店，告诉老板我们要什么，他们就会帮我们准备好，我们只要吃完付钱，就可以了，也不用去管理那些之后的琐事。而<strong>栈</strong>就像我们自己做菜，什么东西都得自己买好，做什么，怎么做都得提前想好。做完之后还需要自己收拾最后的垃圾。</p>
<h2 id="iOS内存管理机制"><a href="#iOS内存管理机制" class="headerlink" title="iOS内存管理机制"></a>iOS内存管理机制</h2><p>当你创建的对象的时候，你总得需要告诉操作系统，你将要在什么时候对占有这块内存的对象进行释放，就像平常生活中，你怎么才能确定这房间里面是有人的还是没有人的呢？</p>
<p>一般来说，我们肯定会这么干，每个人进去的时候登记下，然后出来的时候再登记下，这样只要我们在需要管理的时候看下登记再按的人数是不是为0就可以了，只要为0，那么就说明里面没有人，否则就有人，苹果也是这么处理内存管理的。在你创建一个对象的时候，他会需要进行<code>retain</code>，然后在你不在持有他的时候进行<code>release</code>，所以每个对象都有一个<code>retain count</code>来进行计数。</p>
<p>在iOS中有2套内存管理机制：MRC(MannulReference Counting)和ARC(Automatic Reference Counting)。其中ARC起源于iOS 4.3，在那之前，苹果开发者只能手动使用<code>retain</code>和<code>release</code>来进行内存管理。这样做的问题很明显，如果你在开发过程中，一个不小心没有<code>retain</code>和<code>release</code>成对出现，那么很容易使得内存没有释放，最后导致程序内存不足而导致闪退。</p>
<p>对于ARC，苹果的官方文档是这么解释的：</p>
<blockquote>
<p>Automatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects. Rather than having to think about retain and release operations, ARC allows you to concentrate on the interesting code, the object graphs, and the relationships between objects in your application.</p>
<p>ARC works by adding code at compile time to ensure that objects live as long as necessary, but no longer. Conceptually, it follows the same memory management conventions as manual reference counting (described in Advanced Memory Management Programming Guide) by adding the appropriate memory management calls for you.</p>
</blockquote>
<p>总的来说，主要意思就是ARC在本质上就像MRC一样，但是它能够让你花费更少的时间来考虑代码中的<code>retain</code>和<code>release</code>。与此同时，编译器能够帮你更加准确的将<code>retain</code>和<code>release</code>加在你代码中真正需要的地方。</p>
<p>理解如下图：<br><img src="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Art/ARC_Illustration.jpg" alt="ARC &amp;&amp; MRC"></p>
<p>有人可能会提到GC(Garbage Collection)——垃圾回收机制。在现在的iOS中GC没有被使用，而在MAC OS X中，GC是被使用的，不过对于GC，苹果是这么解释的：</p>
<blockquote>
<p>Garbage collection is deprecated in OS X Mountain Lion v10.8, and will be removed in a future version of OS X. Automatic Reference Counting is the recommended replacement technology. To aid in migrating existing applications, the ARC migration tool in Xcode 4.3 and later supports migration of garbage collected OS X applications to ARC</p>
</blockquote>
<p>总的来说ARC将在未来的某一天来取代GC在MAC中的位置。</p>
<h2 id="property（属性）"><a href="#property（属性）" class="headerlink" title="property（属性）"></a>property（属性）</h2><p>就算理解的再多，我们还是要和实际相结合。实际运用中与之相对应的就是实例变量的属性。<br>由于 iOS 中 MRC已经太过于古老，在这就不再多提。</p>
<p>在ARC中，我们创建实例变量经常是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (atomic/nonatomic/assign/retain/strong/weak/unsafe_unretained/copy) Number* num</div></pre></td></tr></table></figure>
<p>所以我们就为让这内容中的这几个property来进行解释。</p>
<ul>
<li>atomic:原子性，简单的解释就是说，他是线程安全的，但是由于线程安全，在操作的过程中，编译器会自己给他上锁，解锁。这样会造成资源的浪费（因为我们平常开发中不会那么频繁的考虑到线程安全这个问题）<strong>该属性为默认值</strong></li>
<li>nonatomic:非原子性，这个和上面那个是双子星，但是他们正好相反，这个由于不安全的，但是因为没有了锁的问题，这样资源就会尽可能的被利用，所以我们在日常开发中使用这个，而对于他的安全性，我们一般都自己在后期开发的过程中，在使用多线程的过程中进行考虑。</li>
<li>assign:给予了setter方法，assign一般指向一个不是指针指向的对象，比如说<code>CGFloat</code>这类值。（关于<code>assign</code>和<code>weak</code>在delegate中的区别将会在后面提到）</li>
<li>retain:<code>retain</code>用于指向一个有指针的对象，就像MRC中的retain，他是为了增加<code>retain count</code>，这样使得对象能够在<code>autoreleasepool</code>中持有内存</li>
<li>strong:<code>strong</code>是在ARC中用来代替<code>retain</code>的，所以原理相同，即<code>retain count</code>加一</li>
<li>weak:<code>weak</code>和<code>strong</code>一般只要懂一点英语的就知道，他们又是一堆双子星，<code>strong</code>是表示持有，而<code>weak</code>表示，只是简单的引用。这意味着等到持有<code>weak</code>的对象呗释放的时候，<code>weak</code>表示的对象也被释放。而需要注意的是<code>weak</code>释放后他就会为nil。</li>
<li>unsafe_unretained:<code>unsafe_unretained</code>一般很少被用到，主要的原因是他一般用于在Cocoa底层的那些不能支持<code>weak</code>属性的变量，比如说<code>NSTextView</code>，<code>NSFont</code> ，<code>NSColorSpace</code>等。而他和weak不同的地方是，持有<code>weak</code>的对象被释放后，<code>weak</code>对象会被指向nil，而<code>unsafe_unretained</code>则不会被指向为nil。这样就有了安全隐患。</li>
<li>copy:<code>copy</code>一般我们用在<code>NSString</code>，<code>NSArray</code>，<code>NSDictionary</code>，而原因就是copy会在复制的时候讲源对象进行拷贝。这样他只想的将会是一个新的，<code>retain count</code>为1的对象。这样在我们对于这个对象的内容进行修改的时候，它将不会影响到原来的那个对象。</li>
</ul>
<p>除了这几种之外，我们还有4种属性没有提到</p>
<ul>
<li>getter:设置getter方法</li>
<li>setter:设置setter方法</li>
<li>readonly:只读</li>
<li>readwrite：可读写</li>
</ul>
<p>这四种因为可以根据字面意思来进行设置在这就不进行过多的介绍。</p>
<p>这里再补上一句之前提到的问题：</p>
<blockquote>
<p>关于为什么使用<code>weak</code>而不是用<code>assign</code>来对delegate进行标注。</p>
</blockquote>
<p>首先delegate一般的类型都是id，即可以指向所有对象的<code>id</code>类型。所以我们既可以使用assign指向他，也可以使用weak指向他。但是因为weak在不被持有的时候会指向nil，而大家都知道，所有通过nil的方法在调用函数的时候，都会返回为nil，这样就能够保证了程序的稳定性，就算没有东西返回，他还是能够正常解析（只是解析出来的值为nil）。而如果使用assign的话，如果一不持有他。那么下次再调用它的时候，他将会指向一个不知名的地址，即野指针。这样就会使得整个程序crash。</p>
<h2 id="autoreleasepool（自动释放池）"><a href="#autoreleasepool（自动释放池）" class="headerlink" title="autoreleasepool（自动释放池）"></a>autoreleasepool（自动释放池）</h2><p>既然扯到release，那就不得不提下autoreleasepool，顾名思义，他就是一个用来自动帮你释放的池子（这特么不是废话么）。一般情况下我们不怎么会去使用它，因为在AppKit和UIKit的框架中，事情基本上默认的放在<code>autorelease pool block</code>中完成的。这样子当你完成这些内容后，对应在内存中的数据就会自动释放，这样就不需要你手动去处理这些数据，从而保证了程序的安全性。</p>
<p>当然这里也提到了这是在使用AppKit和UIKit的情况下。我们仍然有以下这几种情况来使用autoreleasepool的情况：</p>
<ol>
<li>编写的是命令行程序，不基于UI框架</li>
<li>当你需要写一个循环，循环里面有很多临时变量的时候</li>
<li>当你大量使用辅助线程</li>
</ol>
<p>总的来说autoreleasepool是为了尽可能的减少无用变量在内存中的占用情况。从而使得程序所需要的内存更少。至于autoreleasepool的释放时间，这就要涉及到runloop，具体内容可以参见sunnyxx大神的<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">这篇文章</a>，相信对你肯定有很大帮助。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>循环引用对于内存来说是一个大问题。这个问题我们更多的在block中可能会碰到，不过总结起来就是这么一句话：</p>
<blockquote>
<p>A对象持有B，那么B的<code>retain count</code> 为1，而此时A因为被其他变量持有，所有A的<code>retain Count</code>为1，而B又要引用A，那么A的<code>retain count</code>又要加一，这样等到持有A的那个对象释放A的时候，就算A的<code>retain count</code>减一，但还是为1，所以无法释放，而因为A无法释放，导致B也无法成功释放，而外部没有持有A或B中的任意一个，这样就导致了这块内存空间一直被持有。</p>
</blockquote>
<p>图示如下：<br><img src="http://upload-images.jianshu.io/upload_images/1801379-20918594e616e21d.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="循环引用1"><br><img src="http://upload-images.jianshu.io/upload_images/1801379-410bce0fa4a0ca69.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="循环引用2"></p>
<p>具体的问题我将会在解释block的时候具体说明，需要知道的一点就是，如果存在循环引用，那么就需要把循环引用中间的一条线断掉，从而使用weak来代替，使得当strong的一方被释放的时候，weak也能被</p>
<p>希望以上文章能够对你有所帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/09/Swift中第三方Sqlite3框架SQLite.swift使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/09/Swift中第三方Sqlite3框架SQLite.swift使用/" itemprop="url">Swift中第三方Sqlite3框架SQLite.swift使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-09T10:48:50+08:00">
                2016-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Objective-C中，用于数据持久化的方法有以下几种：</p>
<ol>
<li>使用plist文件</li>
<li>使用preference 保存数据</li>
<li>​</li>
<li>NSKeyArchiver 归档</li>
<li>Sqlite3</li>
<li>CoreData</li>
</ol>
<p>在日常开发中，虽然经常需要储存某些用户的个人信息之类的，这样我们用的更多的是plst和preference，但是对于大批量的数据，比如说TableView中的Data数据进行处理，还是需要数据库来进行处理。</p>
<blockquote>
<p>CoreData是基于Sqlite的封装，但是貌似被黑的很惨，这里就暂时不用了。而且因为我自己尝试使用过CoreData，感觉使用的话，不仅仅需要用到图形界面，还要编写代码。对于我这个纯代码党来说，感觉有点复杂。希望苹果公司将来能够对其进行不断改良吧。</p>
</blockquote>
<p>而在移动端我们最最常用的还是Sqlite，在OC中，我们有耳熟能详的FMDB，但是在Swift中，我们能使用什么呢？在通过网上搜索了一段时间之后。<a href="https://github.com/stephencelis/SQLite.swift" target="_blank" rel="external">SQLite.swift</a>映入了我眼帘（我才不会说因为Realm的文档太复杂而不去看他了呢！）</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="#安装方法"></a>#安装方法</h2><p>对于使用cocoapods的我来说，第三方库的安装其实相对而言十分简单的。</p>
<ol>
<li>只要在该工程下使用<code>vim podfile</code>创建对应的podfile文件<ol>
<li>输入对应的第三方库的名字和版本号：<code>pod &#39;SQLite.swift&#39;, &#39;~&gt; 0.10.1&#39;</code>,由于是Swift我们这里还需要换行输入<code>use_frameworks!</code>这样才能将对应的库导入到我们的工程中。</li>
</ol>
</li>
<li><code>esc</code>后输入<code>:wq</code>，保存文本内容</li>
<li>输入<code>pod install</code>安装对应库就可以了</li>
</ol>
<blockquote>
<p>如果有小伙伴不知道怎么安装cocoapods，可以参照我的<a href="http://blog.csdn.net/zkh90644/article/details/51039365" target="_blank" rel="external">这篇文章</a>来进行安装</p>
</blockquote>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="#基本介绍"></a>#基本介绍</h2><p>这个第三方框架有着自己详细的<a href="https://github.com/stephencelis/SQLite.swift/blob/master/Documentation/Index.md" target="_blank" rel="external">官方文档</a>,各位可以点击进去自行查看。不过都是英文的，可能阅读起来有点麻烦。所以我在这简单的介绍下相关的内容。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="#基本使用"></a>#基本使用</h2><p>##创建<br>对于数据库而言，主要的创建就是数据库的创建和表的创建</p>
<p>###数据库的创建<br>只要直接获取就可以，这个库会帮我们解决如果文件不存在的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let db = try Connection(&quot;path/to/db.sqlite3&quot;)</div></pre></td></tr></table></figure>
<p>###表的创建<br>首先我们通过库中的<code>Table</code>类来获取这个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let table = Table(&quot;tableName&quot;)</div></pre></td></tr></table></figure>
<p>然后我们创建我们需要在表中的放入的元素。<br>这里就需要介绍下<br>Sqlite中存在的值类型和类中的变量的对应情况了。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Swift Type</th>
<th style="text-align:center">SQLite Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Int64</td>
<td style="text-align:center">INTEGER</td>
</tr>
<tr>
<td style="text-align:center">Double</td>
<td style="text-align:center">REAL</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">TEXT</td>
</tr>
<tr>
<td style="text-align:center">nil</td>
<td style="text-align:center">NULL</td>
</tr>
<tr>
<td style="text-align:center">SQLite.Blob</td>
<td style="text-align:center">BLOB</td>
</tr>
</tbody>
</table>
<p>然后就是创建我们想要的元素对象了<br>let id = Column<int>(“id”)<br>let name = Column<string>(“PersonName”)</string></int></p>
<p>其中创建的时候中&lt;&gt;中的值就是我们设置的元素，()中的内容就是元素名</p>
<blockquote>
<p>在SQLite中的所有涉及到元素的增删改查的所有内容都是使用column对象来进行处理的。</p>
</blockquote>
<p>而创建的话也十分简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try db.run(table.create&#123; t in</div><div class="line">	t.column(id,primaryKey:true)</div><div class="line">	t.column(name)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>当然肯定有人会问很多问题</p>
<p>Q<br>:表如果已经存在了，那怎么办？元素的唯一性怎么办？主键怎么设置？……</p>
<p>A:别急，听我慢慢道来。</p>
</blockquote>
<p>这里框架里面已经给我们提供了很多可以遍历的方法</p>
<p>####解决表已经存在的问题<br>我们可以翻看他的源代码中的<code>Table</code>类的创建函数<code>create</code>方法，这个创建方法是这么写的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func create(temporary temporary: Bool = false, ifNotExists: Bool = false, @noescape block: TableBuilder -&gt; Void) -&gt; String</div></pre></td></tr></table></figure>
<p>很明显他里面已经帮我们考虑了我们平常使用中的常用方法，其中temporary就是创建虚拟表（也就是存放在内存中，不存放在实际沙盒路径中的数据表），ifNotExists是判断是否已经存在对应的表文件。block是用来创建对应的<code>TableBuilder</code>对象。</p>
<p>####解决元素的相关属性问题<br>在create的时候我们使用了闭包，这样就可以在每次执行的时候捕获对象，从而使得每次都能对表进行处理。通过查看他的源码，我们发现这里面的t实际上就是一个TableBuilder对象。我们可以用TableBuilder的column方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func column(name: Expressible, _ datatype: String, _ primaryKey: PrimaryKey?, _ null: Bool, _ unique: Bool, _ check: Expressible?, _ defaultValue: Expressible?, _ references: (QueryType, Expressible)?, _ collate: Collation?)</div></pre></td></tr></table></figure>
<p>当然我们不会直接调用这个方法，毕竟这个方法那么长，不符合Swift编码规范，所以我们可以使用作者已经缩略好的内容，从而方便使用，这里就粗略的介绍下对应变量：</p>
<ol>
<li>name:对应的Expression类型，也就是我们前面创建的Express&lt;&gt;()的变量</li>
<li>Datetype：元素的类型，就是前面表格中的SwiftType，一般代码会帮我们自动设置好</li>
<li>primaryKey：判断是否要设置为主键</li>
<li>null：是否可以置为null，</li>
<li>unique：是否键值唯一</li>
<li>check：判断对应的内容是否符合某种表解析，比如说：email.check(“%@%”)，</li>
<li>reference：添加引用</li>
<li>collate：指定排序规则</li>
<li>defaultValue：默认值</li>
</ol>
<h2 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h2><p>###增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try! db.run(users.insert(email &lt;- &quot;alice@mac.com&quot;))</div></pre></td></tr></table></figure>
<p>这个返回的是一个Int，即插入对应的行的行id</p>
<p>###删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try db.run(alice.delete())</div></pre></td></tr></table></figure>
<p>这个返回的是一个Int，即删除行的数目</p>
<p>那如果需要删除某一行，那就需要使用对应的筛选函数了（在查找中会提到）</p>
<p>###修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">try db.run(alice.update(email &lt;- &quot;alice@me.com&quot;))</div></pre></td></tr></table></figure>
<p>这个返回的是一个Int，即修改行的数目</p>
<p>###查找<br>查找和上面的略有不同，因为我们查找，肯定是为了查找某一行的内容，或者说需要对内容进行排列，或者左右连接其他表等等。这个时候我们就需要使用其他的函数了。（因为框架里面没有select方法）</p>
<p>在框架中查找对应的是内容的QueryType的函数主要有这几个filter（筛选），join（表连接），group（group by），limit（对筛选条件进行约束），这几个函数与日常使用的SQL语句使用基本上一致，所以在这不过多解释。但是在使用filter的时候，如果判断值为某个值，那么需要用到column。所以在每次选择前，需要对需要用到的值创建对象。</p>
<p>但是由于选出的值需要进行展示，而且不同人的展示方式不同，比如说有的人要取和，有的人要输出。</p>
<blockquote>
<p>除此之外，对于筛选的内容，框架的作者使用链式的方法，从而在编码的过程中更加方便，比如说下面这条语句，很明显让人一读就能力姐他到底是什么意思。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let query = users.select(email)           // SELECT &quot;email&quot; FROM &quot;users&quot;</div><div class="line">                 .filter(name != nil)     // WHERE &quot;name&quot; IS NOT NULL</div><div class="line">                 .order(email.desc, name) // ORDER BY &quot;email&quot; DESC, &quot;name&quot;</div><div class="line">                 .limit(5, offset: 1)     // LIMIT 5 OFFSET 1</div></pre></td></tr></table></figure>
<p>###数据转换<br>这个时候单纯的table是不够用了，作者就把方法写到了db里面。</p>
<ol>
<li>scalar:聚合，用来获得对应想要的<strong>数</strong>值,一般用于获得count,max,min,avg,sum,totle等</li>
<li>prepare:获得所有元素值，然后使用for循环进行遍历（在for循环中，如果想要某个元素的值，你需要使用<code>let idNum = item[id]</code>id为column对象）</li>
<li>pluck:获得一行，如果是选取了所有，那么获得第一行</li>
<li>run:用来执行delete，update，insert，create语句</li>
<li>trace:每次执行sql语句都要执行这里面的内容。（<code>db.trace { print($0) }</code>在执行db的所有方法前，使用这句，会在每次执行的时候都输出sql语句）</li>
<li>excuse:直接执行SQL语句，为了方便写习惯了SQL语句的人。</li>
</ol>
<p>##删除<br>删除表可以直接使用<code>drop()</code>方法而删除某一标签，即dropIndex，则调用<code>dropIndex</code>方法。</p>
<blockquote>
<p>除此之外，之所以这个框架那么好用，他还重载了符号。比如说你需要写入某个column，你可以使用<code>&lt;-</code>，这大大的方便了代码的可读性，从而提高了理解的效率。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/08/[译]10条在开发基于React Native开发中学到的事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/[译]10条在开发基于React Native开发中学到的事/" itemprop="url">10条在开发基于React Native开发中学到的事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-08T14:29:50+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://medium.com/@tomgoldenberg/10-things-we-learned-while-building-a-react-native-app-44e22f1c06f#.l8kog0zgt" target="_blank" rel="external">点我跳转（国内可能无法访问）</a></p>
<p><a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>是令人兴奋的。它是的开发iOS和安卓的App变成了一段十分有趣的经历。然而这仍旧有一些我和我的伙伴 Nicholas Alan Brown 觉得在我们开始开发一款准备要开发的App中需要掌握的要点</p>
<p>虽然我们都有着全职工作，但是我们决定为《博伽梵歌》——古老的印度教宗教文本做一个iOS App。我在印度的大学上过这样的课，我觉得这将会是一个简单的练手工程。下面是这个App的最后产品截图，你也可以在<a href="https://itunes.apple.com/us/app/id1071711190" target="_blank" rel="external">App Store</a>中获取它。</p>
<p><img src="https://cdn-images-1.medium.com/max/400/1*GheZ6eq8cvBFR2IiTX3bJQ.png" alt="图片1"></p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*dhRIGl71u2b5_ZtLcIPw0w.png" alt="图片2"></p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*kHpDbpJuL34PsfSjqB7lEw.png" alt="图片3"></p>
<p>然而当我们开发这个App的时候，就像一个笑话，我们在开发过程中碰到了一些障碍。我将在下面高亮的显示出10点我们所面对的，而且通过许多方法最终解决的。我觉得这可能对于其他没有足够多的时间或者像大型企业一样有充足资源的独立开发者有一定的帮助。</p>
<h2 id="1-你必须捆绑你的App在你上交到App-Store之前"><a href="#1-你必须捆绑你的App在你上交到App-Store之前" class="headerlink" title="1.你必须捆绑你的App在你上交到App Store之前"></a>1.你必须捆绑你的App在你上交到App Store之前</h2><p>这里有一些令人尴尬的困难，但是他确确实实发生在许多<em>React Native</em> 开发者，特别是对于那些没有Xcode/Swift开发经验的开发者。及时你的App可能在你Xcode的模拟器上顺利的运行，但是你仍需要捆绑（打包）。如果你没有打包并且提交到App Store，苹果的工作人员会一直拒绝你的提交，就像下面这张图中的一样。<br><img src="https://cdn-images-1.medium.com/max/2000/1*YNKTErKu5U7klVQPixJfKg.png" alt="图片4"></p>
<p>你会发现，他有2个拒绝因为我确实做错了的原因。虽然尽可能快的开始并将App发布到App Store上是令人激动的，但是我不建议这么做，除非：1. 你能够在你的设备上跑这个包，2.你能够在你的设备上顺利的通过TestFlight的Beta测试。<a href="https://facebook.github.io/react-native/docs/running-on-device-ios.html" target="_blank" rel="external">这里</a>有一些打包你App的信息。当然，这些文档中的打包方法有一些困难，但是我们将在接下来的补充上。</p>
<h2 id="2-更新你的React-Native版本"><a href="#2-更新你的React-Native版本" class="headerlink" title="2. 更新你的React Native版本"></a>2. 更新你的React Native版本</h2><p>这对我们来说可能有一些困难。每次我们升级到最新版本的时候，所有的东西都会出问题。然后我们将会很难弄出一个稳定的版本。对于这个问题的解决方法是删除<em>node_modules</em>这个文件夹，关闭所有进程，然后使用<code>npm install</code>，然后用<code>command + shift + k</code>来清理整个App，用<code>command + shift + b</code>来重建整个App，最后使用<code>command + r</code>来重新运行整个App。学习这个方法在无法成功重建或者我们想要使用下一个版本的过程中是十分有用的。</p>
<h2 id="3-场景交换动画"><a href="#3-场景交换动画" class="headerlink" title="3. 场景交换动画"></a>3. 场景交换动画</h2><p>在<a href="https://www.reddit.com/r/IAmA/comments/3wyb3m/we_are_the_team_working_on_react_native_ask_us/" target="_blank" rel="external">reddit Thread</a>中，我们问了这个团队为什么使用<code>Navigator</code>这个控件来进行页面跳转十分慢。当我们简单的使用<code>Navigator</code>控件你会发现界面的跳转动画永远是断断续续的。在安卓端这个断断续续的现象更加明显，即使我使用了最新的版本也是这样。这个React Native的团队响应说，他们解决的方法是卸载了native代码中的JS动画，因为JS中的代码堆积导致了掉帧。事实上，存在一个模块<code>InteractionManager</code>，文档<a href="https://facebook.github.io/react-native/docs/performance.html#slow-navigator-transitions" target="_blank" rel="external">连接</a>，我们发现当<code>Navigator</code>和<code>InteractionManager</code>一起工作的时候，他将会运行的十分良好。然而当我们的很多东西都使用更快而且更加原生的NavigatorIOS。而这的缺点是，他不能在复杂的App（译者注：比如Android，因为是iOS原生）中来管理各个界面的状态。幸运的是，我们的App是相当的简单，不需要太多的界面的路由交换。将来我们将会使用<code>Navigator</code>来代替他</p>
<h2 id="4-用户分析"><a href="#4-用户分析" class="headerlink" title="4. 用户分析"></a>4. 用户分析</h2><p>在整个开发中最阻挠我们的是对于用户的分析，而原因是因为我们在这上面花费了太多时间。当我们开始的时候，我们知道用户分析将会对我们的营销和发展策略投放市场产生巨大的影响，我们尝试用<code>Google Analytics</code>来解决整个问题，但是没有发现可以用的<em>React Native</em>包（你可以在这个网页中找到:<a href="http://stackoverflow.com/questions/34125784/how-to-set-up-analytics-on-react-native-for-ios" target="_blank" rel="external">点击跳转</a>）</p>
<p>最后我们决定写我们自己的我们使用<a href="https://segment.com/" target="_blank" rel="external">Segment Analytics</a>的连接文件。当我听到Chris Smothers也这样做了之后，我备受鼓舞。接下来是创建方法：</p>
<ol>
<li>将Segment集成到podfile中，集成方法<a href="https://segment.com/docs/sources/mobile/ios/" target="_blank" rel="external">链接地址</a>。如何在React Native如何使用podfile的方法在：<a href="https://facebook.github.io/react-native/docs/embedded-app-ios.html" target="_blank" rel="external">链接地址</a>。</li>
<li>在同一部分中，比如在这里他叫做<em>SEGAnalyticsConfiguration</em>,你讲配置文件放到<em>AppDelegate.m</em>文件中。</li>
<li>你写一个帮助模块来将<em>Segment分析函数</em>写到你的App中，要点<a href="https://gist.github.com/tgoldenberg/3e32e4988a08081d62ce" target="_blank" rel="external">在这</a>。最后在用户登录，打开某个页面的时候，你就可以App中调用<code>AnalyticsHelper</code>模块函数，来对用户数据进行记录。</li>
</ol>
<h2 id="5-动画"><a href="#5-动画" class="headerlink" title="5.动画"></a>5.动画</h2><p>动画对于许多App来说是一个很棒的方面，无论适当用户提交评论（在iPhone上的通知消息的上滑提醒），或者是在进入界面的时候淡入，或者滑动动画，这绝对是很重要的。</p>
<p>同时React Native的动画模块也是十分棒的。同时他也有着很好的文档。这就使得我们在使用过程中更加简单。我们可以对每个控件使用动画模块直到我发现<a href="https://github.com/oblador/react-native-animatable" target="_blank" rel="external"><em>Animatable</em></a>模块。如果你以前用过CSS库 <code>animated.css</code>，这个动画库和CSS库很相似，他又很多便于使用的动画，同时他也十分便于配置。我们在我们的序列中就是使用了其中的动画——从屏幕顶端进入，并且在进入主屏幕的时候展开，同时降低透明度</p>
<h2 id="6-notbrent（一个大牛的名字）"><a href="#6-notbrent（一个大牛的名字）" class="headerlink" title="6.@notbrent（一个大牛的名字）"></a>6.@notbrent（一个大牛的名字）</h2><p>这家伙十分令人吃惊，每当Nick和我有问题的时候——无论是界面交互，列表的进入，滑动动画，所有解决方法都来自Brent Batne。这家伙对<em>React Native</em>有着巨大的贡献，同时在很多的例子Demo，你可以Follow他的<a href="https://github.com/brentvatne" target="_blank" rel="external">Github</a>，Brent，感谢你的帮助:)</p>
<h2 id="7-使用CodePush"><a href="#7-使用CodePush" class="headerlink" title="7.使用CodePush"></a>7.使用CodePush</h2><p>使用它。Just Do IT。相信我，这是值得的。在<a href="http://www.meetup.com/React-Native-NYC/" target="_blank" rel="external"><em>React Native NYC</em></a>之后我学着去使用<a href="https://github.com/Microsoft/code-push" target="_blank" rel="external"><em>CodePush</em></a>。<em>Delivery.com</em>上Jesse Sessler 和 Bruno Barbieri两个大牛说，他们集成React Native到Delivery.com的iOS App上，你可以在<a href="http://www.meetup.com/React-Native-NYC/" target="_blank" rel="external">这里</a>来看他们的介绍。他们展示了如何使用CodePush来使得公司的的开发发生了革命性的改变。CodePush可以使你直接push你的代码到你的App上，而不需要再经过传统的App Store的更新。这意味着你的用户手中的App将在悄无声息中进行更新。这又很多优点：比如说你能使得程序不断的review，而不是通过后续版本来更替他们。同时这也可以使得你可以快速的来修复程序中的Bug。你可以十分容易的在这个<a href="https://github.com/Microsoft/code-push" target="_blank" rel="external">文档</a>中了解到如何去使用它。</p>
<h2 id="8-社会分享"><a href="#8-社会分享" class="headerlink" title="8.社会分享"></a>8.社会分享</h2><p>分享问题使我们一直在纠结的，当我们把App发布到TestFlight上面的时候，一个相同的问题就是当我们点击<em>分享</em>按钮的时候，这回需要很长时间来跳出分享的选项界面。我们以前使用<code>react-native-activity-view</code>包，并且想要弃用他。现在我们使用<a href="https://github.com/doefler/react-native-social-share" target="_blank" rel="external"><code>react-native-social-share</code></a>，他没有别的，比如说：email，twitter之类的分享，他只有FaceBook，我们发现分享的速度有了显著的提高，但是仍旧不是很棒。事实证明，分享永远是很慢的，及时使用原生的Swift App，但是这将会在未来有很大的改善。</p>
<h2 id="9-App图标，加载界面等"><a href="#9-App图标，加载界面等" class="headerlink" title="9.App图标，加载界面等"></a>9.App图标，加载界面等</h2><p>如果你以前没有iOS开发经验，这些东西就会对你有一定的阻挠。我很幸运的是Nick是一个全职的移动端的产品经理，所以我让他来解决这些问题，但是这仍旧让我们很困惑，因为就算你获得了app图标和加载界面，并且能够正确的运作了，你仍旧不得不提交不同种类的屏幕截图到App Store的提交界面中。我不是这方面的额专家，但是我发现<a href="https://makeappicon.com/" target="_blank" rel="external">这个网站</a>对于获得不同icon的尺寸很有帮助。同时我发现Ray Wendlich的<a href="http://www.raywenderlich.com/8003/how-to-submit-your-app-to-apple-from-no-account-to-app-store-part-1" target="_blank" rel="external">辅导课</a>也是十分有帮助的，即使App提交的方式一致在改变，但是我觉得你不用害怕他。</p>
<h2 id="10-react-native打包命令"><a href="#10-react-native打包命令" class="headerlink" title="10.react-native打包命令"></a>10.react-native打包命令</h2><p>首先，这里的内容不适用于最新的版本。react-native的打包命令在新的发布版本中已经发生了改变。现在他有了很多不同的选项。列举如下：</p>
<ol>
<li>-platform 这里是决定是iOS还是安卓</li>
<li>-bundle-output 这是你<code>main.js</code>的bundle文件的位置。</li>
<li>-dev 通常你要设置为false</li>
<li>-entry-file是你<code>index.ios.js</code>的文件位置。</li>
<li>-assetsdest 这是一个令人迷惑的参数，因为这似乎是打包你的文件资源（assets）。然而，在很多情况下，你不需要去特别在意他。相对的，在你的<code>node_modules/react-native/packager</code>路径下的一个文件已经已经打包好了你的文件资源(assets)。为什么他记录的那么好，我不是很清楚，可能是因为如果当我们试着去打包的时候，再去找起来相关的信息可能就十分麻烦了。无论如何只要运行<code>node_modules/react-native/packager/react-native-xcode.sh</code>，他就会打包所有你的资源。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你能喜欢这篇文章，尽管遇到了这么多困难，我相信React Native将会在未来的移动市场有一个美好的未来。毕竟我和我的伙伴从开始搭建到最后发布，只要短短2个月时间。</p>
<p>（译者注，因为后面全是广告，我就不翻译下去了。）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/08/[译]autolayout_uitableView_stackoverflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/[译]autolayout_uitableView_stackoverflow/" itemprop="url">iOS中使用autolayout来进行UITableView的布局(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-08T11:52:59+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于昨天翻译的一篇内容是原作者在2014年写的，可能有点老。所以这次翻译的是stackoverflow中<a href="http://stackoverflow.com/users/796419/smileyborg" target="_blank" rel="external">smileyborg</a>解释的获得1.8k的回答：<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">原文链接</a>。</p>
<hr>
<p>###使用AutoLayout来动态显示UITableView中Cell的高度</p>
<p><strong>TL;DR:</strong>(Too long,Don’t read，太长不看)如果你不想阅读内容，你可以直接跳转到这个github上简单的工程：</p>
<ul>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="external">iOS 8工程</a> - 需要iOS8以上</li>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayout" target="_blank" rel="external">iOS 7工程</a> - 需要iOS7+以上</li>
</ul>
<p>####概念描述</p>
<p>最开始的两步与你所开发的iOS的版本号无关</p>
<p>#####1.设置并添加约束<br>在你的<code>UITableViewCell</code>的子类中，通过约束你的cell的subView从而使得他们有自己的边框，从而撑起这个cell的<strong>contentView</strong>（最主要的是上下边的约束）。</p>
<p><strong>注意：不要设置cell的subView与cell本身的约束，只能和cell的<code>contentView</code>约束。</strong></p>
<p>让我们使用内容真正的大小来设置tableViewCell的内容，并通过设置内容在垂直方向上的<em>压缩阻力(content compression resistance)</em>和<em>内容收缩约束(content hugging constraints)</em>来重新加载他的尺寸。（如果对于content Compression Resistance和Content Hugging Constraints有疑惑可以点击：<a href="http://stackoverflow.com/questions/22599069/what-is-the-content-compression-resistance-and-content-hugging-of-a-uiview" target="_blank" rel="external">这个连接</a></p>
<p>记住，这个方法（指设置压缩阻力和内容收缩约束）是为了能够cell的subView能够在垂直方向上能够与cell相连接，从而当内容“产生压力”的时候他们能够伸展内容的View从而适应他们。就如下面的这个例子中展出的部分约束（不是全部！）：<img src="http://i.stack.imgur.com/CTUPi.png" alt="exampleImage"></p>
<p>你能够想象，就如例子中一样，当内容在多行的label中不断增加的时候，label将会更好的变宽从而使得使得内容变得更加合适。（当然，为了能够使Cell更好的显示出来，你需要设置正确的约束）</p>
<p>设置正确的约束是使用AutoLayout动态获得cell高度最困难同时也是最重要的一步。没有这一步，其余的都只是无用功。所以在这一步上面请花费一定的时间。我建议你通过代码来实现约束，这样可以更好的明白你在哪里添加了这些约束，同时对于调试来说，这可以更好的找到错误。通过代码添加约束比通过interface Builder更加方便、有效，特别是通过某些别人已经设置好的API。这里是我所设计、维护、使用的一个<a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="external">第三方库</a>(译者表示：我更喜欢用Masonry和SnapKit)</p>
<ul>
<li>如果你在代码中添加了约束，你将至少使用一次<code>updateConstraints</code>方法来设置你的UITableViewCell的subClass。注意：因为<code>updateConstraints</code>在你的代码中将不止一次的被调用，所以不要反复添加一样的约束，通过检查<code>didSetupConstraints</code>函数返回的布尔值(boolean)来确定<code>updateConstraints</code>中包含的内容是否只包含了一次。(你可以在你运行了一次你的约束后，将他设置为YES)。另一方面，如果你有代码来更新已经存在的约束（比如说调整某些约束的常量属性），请将这些更新的代码放在<code>updateConstraints</code>中，但是在检查<code>didSetupConstraints</code>以外。这样你可以在每次运行的时候都调用它。</li>
</ul>
<p>#####2.设置TableViewCell的唯一标示符。<br>对于每一个唯一的cell中的约束，使用一个唯一的标示符来设置有这些约束的Cell。另一方面来说，如果你的cell有不止一个的独一无二的layout，每一个唯一的layout都应该有一个他自己的标示符。（这里有一个建议，一般你只有当你的Cell的subViews发生改变或者他们按照不同位置发生排列的时候，才会用新的标示符。）</p>
<p>比如说，如果你在每个cell中展示每一条email的内容的时候，你可能需要4种展示方式：有主题的邮件，有主题和文章主体的邮件，有主题和照片附件的邮件，有主题、文章主体还有照片附件的邮件。每种展示方式都有自己的不同约束来实现它，所以当你的cell创建并且添加约束的时候，每种不同的cell需要给予特定的标示符。这意味着当你将cell放入缓存池的时候，他们当中已经加入了各自的约束，并且已经设定好了他们的类型。</p>
<p>注意：由于内容的大小不同，所以cell有着一样的约束可能仍旧有不同的高度。不要因为内容有着不同的大小，却需要设置不同的layout（不同的约束）和计算框架方式不同（通过相同的约束进行解决）而感到迷惑。</p>
<ul>
<li>不要将有着完全不同约束的cell添加到同一个缓存池<em>（reuse pool）</em>（比如说使用相同的标示符），同时企图删掉老的约束来重新开始来设置每一个缓寸池中的cell。因为Autolayout的内部不是用来进行大规模的约束变化，如果你这么做的话，你将会看到明显的性能问题。</li>
</ul>
<p>####对于iOS 8 - 自行调整大小的cell</p>
<h5 id="3-使用行高的自动估计"><a href="#3-使用行高的自动估计" class="headerlink" title="3.使用行高的自动估计"></a>3.使用行高的自动估计</h5><p>对于iOS 8 ，苹果公司已经在你使用iOS 8之前内化了大量的工作，为了能够使用这种行高的自动估计，你必须首先设置他的<code>rowHeight</code>这一属性，一般我们把它设置为<code>UITableViewAutomaticDimension</code>。然后你需要设置tableView的<code>estimatedRowHeight</code>来开启行高估计，同时这个属性不能为0，下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.tableView.rowHeight = UITableViewAutomaticDimension;</div><div class="line">self.tableView.estimatedRowHeight = 44.0; // 设置你cell的均值</div></pre></td></tr></table></figure>
<p>这是为了在你的cell还没有显示到屏幕上之前，先给予你的tableView中的每一个cell一个临时的估计高度（占位符）。为了得到每一行的准确高度，tableView自动询问每一个cell，他们自己内部基于cell自身固定宽度的内容视图，从而确定自身的<code>contentView</code>的高度（这将基于tableView自己的宽度减去外部的索引或者他的附属视图）和你添加到cell的View和SubView的autolayout的约束。当cell的实际高度被计算出来之后，老的估算高度将会被更新为新的高度，同时它将调整为你所需要的tableView的<code>contentSize</code>和<code>contentOffset</code></p>
<p>总的来说，你所设置的估算高度不会被真的调用，这只是用来设置tableView中正确大小的滚动指示符，同时在你的cell被显示到屏幕上的时候，这种方法将很好的调整那些不正确的估算值。你应该设置<code>estimatedRowHeight</code>这个tableView中的属性（一般在<code>viewDidLoad</code>或者和他类似的方法中）为行的均高。只有当你的行高产生极端变化（例如相差了一个数量级），你就会发现你的滚动指示符发生“跳动”的时候，你才需要费心去实现<code>tableView:estimatedHeightForRowAtIndexPath</code>方法，从而去做最小的计算，从而返回更加精确的cell的高度值。</p>
<p>####对于iOS 7 - 自行实现行高的自动调整</p>
<h5 id="3-实现一个合理的布局从而获得cell的高度"><a href="#3-实现一个合理的布局从而获得cell的高度" class="headerlink" title="3.实现一个合理的布局从而获得cell的高度"></a>3.实现一个合理的布局从而获得cell的高度</h5><p>首先实例化一个不会出现在屏幕上的tableViewCell的例子，<em>这个cell将会被设置一个所有cell都会使用的重用表示符</em>，这个cell将被进行严格的高度计算（不会出现在屏幕上意味着他只是一个属性，同时将不会在<code>tableView:cellForRowAtIndexPath:</code>调用，这意味他不会被渲染到屏幕上）然后，这个cell将会被添加将来显示在tableView中的具体的内容，（比如说文本，图片等等）。</p>
<p>然后迫使这个cell立即调整他的subView的布局，同时使用UItableViewCell的content的<code>systemLayoutSizeFittingSize:</code>方法来获得这个cell所需要的高度。使用<code>UILayoutFittingCompressedSize</code>来获得用来撑开cell的内容的最小的大小。高度必须靠代理中的<code>tableView:heightForRowAtIndexPath:</code>方法来返回。</p>
<h5 id="4-使用预设置的行高"><a href="#4-使用预设置的行高" class="headerlink" title="4.使用预设置的行高"></a>4.使用预设置的行高</h5><p>如果你的tableView有多行的内容，你将会autolayout的约束将会使得主线程在第一次加载tableView的时候产生问题，那是因为<code>tableView:heightForRowAtIndexPath:</code>方法将会在每一行第一次被调用的时候。（为了计算滚动指示符正确的大小）</p>
<p>对于iOS 7，你能够（或者说你绝对应该）在tableView中使用<code>estimatedRowHeight</code>属性，在没有被显示到屏幕上前，这将会给予tableView一个预估的行高（占位符）。然后这个cell在放到屏幕上的时候，每一行的高度将会被计算（通过调用<code>tableView:heightForRowAtIndexPath:</code>方法），同时这个真实高度将替代原有的预估的行高（占位符）。</p>
<p><strong>//这一段和iOS 8的第三段一模一样</strong><br>总的来说，你所设置的估算高度不会被真的调用，这只是用来设置tableView中正确大小的滚动指示符，同时在你的cell被显示到屏幕上的时候，这种方法将很好的调整那些不正确的估算值。你应该设置<code>estimatedRowHeight</code>这个tableView中的属性（一般在<code>viewDidLoad</code>或者和他类似的方法中）为行的均高。只有当你的行高产生极端变化（例如相差了一个数量级），你就会发现你的滚动指示符发生“跳动”的时候，你才需要费心去实现<code>tableView:estimatedHeightForRowAtIndexPath</code>方法，从而去做最小的计算，从而返回更加精确的cell的高度值。</p>
<h5 id="5-添加行高缓存"><a href="#5-添加行高缓存" class="headerlink" title="5.添加行高缓存"></a>5.添加行高缓存</h5><p>如果你已经做了以上所有步骤，但是仍旧不能忍受设备因为调用<code>tableView:heightForRowAtIndexPath:</code>方法去计算约束时候显示tableView的缓慢，你可能很不幸的需要缓存cell的高度（这个建议来自于苹果的工程师）。总的想法是通过autolayout来计算第一次约束，然后通过缓存来计算将来需要使用的所有cell的高度。在使用这个方法的时候，你需要清楚的知道缓存中的行高和什么时候缓存中的行高将会发生改变。这将用于当cell的内容发生改变或者一些其他重要的事情发生的时候（比如说用户通过滑块来动态的调整文本的大小时候）</p>
<h5 id="iOS-7简单的代码实现（基于很多建议）"><a href="#iOS-7简单的代码实现（基于很多建议）" class="headerlink" title="iOS 7简单的代码实现（基于很多建议）"></a>iOS 7简单的代码实现（基于很多建议）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    //设置标示符</div><div class="line">    static NSString *reuseIdentifier = ...;</div><div class="line"></div><div class="line">    //获取缓存池中的cell</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseIdentifier];</div><div class="line"></div><div class="line">    // 设置cell的内容</div><div class="line">    // cell.textLabel.text = someTextForThisCell;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    // 确定约束已经被添加</div><div class="line">    // 或者对约束进行调整</div><div class="line">    // 如果你确定约束已经被设定好，记得更新约束</div><div class="line">    // 更新的方法: [cell setNeedsUpdateConstraints];</div><div class="line">    [cell updateConstraintsIfNeeded];</div><div class="line"></div><div class="line">    // 如果你使用多行的Label,不要忘记正确的使用preferredMaxLayoutWidth</div><div class="line">    // 记得在子类中也进行调用</div><div class="line">    // -[layoutSubviews] 方法. For example:</div><div class="line">    // cell.multiLineLabel.preferredMaxLayoutWidth = CGRectGetWidth(tableView.bounds);</div><div class="line"></div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    // Determine which reuse identifier should be used for the cell at this</div><div class="line">    // index path.</div><div class="line">    NSString *reuseIdentifier = ...;</div><div class="line"></div><div class="line">    // Use a dictionary of offscreen cells to get a cell for the reuse</div><div class="line">    // identifier, creating a cell and storing it in the dictionary if one</div><div class="line">    // hasn&apos;t already been added for the reuse identifier. WARNING: Don&apos;t</div><div class="line">    // call the table view&apos;s dequeueReusableCellWithIdentifier: method here</div><div class="line">    // because this will result in a memory leak as the cell is created but</div><div class="line">    // never returned from the tableView:cellForRowAtIndexPath: method!</div><div class="line">    UITableViewCell *cell = [self.offscreenCells objectForKey:reuseIdentifier];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell = [[YourTableViewCellClass alloc] init];</div><div class="line">        [self.offscreenCells setObject:cell forKey:reuseIdentifier];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Configure the cell with content for the given indexPath, for example:</div><div class="line">    // cell.textLabel.text = someTextForThisCell;</div><div class="line">    // ...</div><div class="line"></div><div class="line">    // Make sure the constraints have been set up for this cell, since it</div><div class="line">    // may have just been created from scratch. Use the following lines,</div><div class="line">    // assuming you are setting up constraints from within the cell&apos;s</div><div class="line">    // updateConstraints method:</div><div class="line">    [cell setNeedsUpdateConstraints];</div><div class="line">    [cell updateConstraintsIfNeeded];</div><div class="line"></div><div class="line">    // Set the width of the cell to match the width of the table view. This</div><div class="line">    // is important so that we&apos;ll get the correct cell height for different</div><div class="line">    // table view widths if the cell&apos;s height depends on its width (due to</div><div class="line">    // multi-line UILabels word wrapping, etc). We don&apos;t need to do this</div><div class="line">    // above in -[tableView:cellForRowAtIndexPath] because it happens</div><div class="line">    // automatically when the cell is used in the table view. Also note,</div><div class="line">    // the final width of the cell may not be the width of the table view in</div><div class="line">    // some cases, for example when a section index is displayed along</div><div class="line">    // the right side of the table view. You must account for the reduced</div><div class="line">    // cell width.</div><div class="line">    cell.bounds = CGRectMake(0.0f, 0.0f, CGRectGetWidth(tableView.bounds), CGRectGetHeight(cell.bounds));</div><div class="line"></div><div class="line">    // Do the layout pass on the cell, which will calculate the frames for</div><div class="line">    // all the views based on the constraints. (Note that you must set the</div><div class="line">    // preferredMaxLayoutWidth on multi-line UILabels inside the</div><div class="line">    // -[layoutSubviews] method of the UITableViewCell subclass, or do it</div><div class="line">    // manually at this point before the below 2 lines!)</div><div class="line">    [cell setNeedsLayout];</div><div class="line">    [cell layoutIfNeeded];</div><div class="line"></div><div class="line">    // Get the actual height required for the cell&apos;s contentView</div><div class="line">    CGFloat height = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height;</div><div class="line"></div><div class="line">    // Add an extra point to the height to account for the cell separator,</div><div class="line">    // which is added between the bottom of the cell&apos;s contentView and the</div><div class="line">    // bottom of the table view cell.</div><div class="line">    height += 1.0f;</div><div class="line"></div><div class="line">    return height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOTE: Set the table view&apos;s estimatedRowHeight property instead of</div><div class="line">// implementing the below method, UNLESS you have extreme variability in</div><div class="line">// your row heights and you notice the scroll indicator &quot;jumping&quot;</div><div class="line">// as you scroll.</div><div class="line">- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    // Do the minimal calculations required to be able to return an</div><div class="line">    // estimated row height that&apos;s within an order of magnitude of the</div><div class="line">    // actual height. For example:</div><div class="line">    if ([self isTallCellAtIndexPath:indexPath]) &#123;</div><div class="line">        return 350.0f;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 40.0f;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####简单的Demo工程</p>
<ul>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="external">iOS 8 工程</a></li>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayout" target="_blank" rel="external">ios 7 工程</a></li>
</ul>
<p>这几个工程完全解决了因为UILabel的情况下tableView需要中cell的高度需要动态调整的问题。</p>
<p>你可以随时提出任何问题或者你所遇到的问题（你可以在Github上提交你的评论），我将尽力帮助你！</p>
<p>####Xamarin（C# / .NET）<br>如果你使用Xamarin，可以检出<a href="http://stackoverflow.com/users/5380/kent-boogaart" target="_blank" rel="external">KentBoogaart</a>的一个<a href="https://github.com/kentcb/TableViewCellWithAutoLayout_dotNET" target="_blank" rel="external">简单的工程</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/21/ios多线程开发——nsthread的简单运用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/21/ios多线程开发——nsthread的简单运用/" itemprop="url">iOS多线程开发——NSThread的简单运用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-21T21:38:50+08:00">
                2016-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前段时间写了<a href="http://blog.csdn.net/zkh90644/article/details/51944923" target="_blank" rel="external">NSOperation</a>，<a href="http://blog.csdn.net/zkh90644/article/details/51934062" target="_blank" rel="external">GCD</a>，最后肯定不能拉下<strong>NSThread</strong>。毕竟既然学了iOS，该了解的总得都了解的。</p>
</blockquote>
<p>##介绍<br><strong>NSThread</strong>相对于GCG和NSOperation来说更加轻量级。毕竟从名字看起来一看就是用来控制线程（Thread）的。正如苹果官网上对他的解释：</p>
<blockquote>
<p>An <strong>NSThread</strong> object controls a thread of execution. Use this class when you want to have an Objective-C method run in its own thread of execution. Threads are especially useful when you need to perform a lengthy task, but don’t want it to block the execution of the rest of the application. In particular, you can use threads to avoid blocking the main thread of the application, which handles user interface and event-related actions. Threads can also be used to divide a large job into several smaller jobs, which can lead to performance increases on multi-core computers.</p>
</blockquote>
<p>可能看了很烦，不过总结下来就是一句话：你可以用线程来将一个大的任务分割成很多小任务来处理，从而提高效率，不过不要阻碍某个线程（特别是主线程，因为他控制了用户的交互），这很容易造成不好的用户体验。</p>
<p>不过由于他是轻量级的，它里面的方法就会比较少，我们需要记忆的也比较少，不过记忆的比较少的后果就是，我们在使用它的时候，需要关心的东西可能就比较多了，比如：线程同步（这个是多线程最伤脑的一个问题）。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="##基本使用"></a>##基本使用</h2><p>###一、创建<br><code>- initWithTarget:selector:object:</code>和<code>init</code>这两个方法，相信只要作为一个iOS开发者的话，应该看到函数名就能知道如何使用了。</p>
<p>###二、使用</p>
<p>####运行线程<br>使用的话，因为系统版本的关系，有一定的区分</p>
<ol>
<li>如果在OS X 10.5以前的话，由于只有<code>detachNewThreadSelector:toTarget:withObject:</code>方法，所以只能使用这个方法。</li>
<li>在OS X 10.5以后，苹果给我们添加了一个更加方便的方法<code>start</code>。只要你设置完Thread的相关内容，直接start他就能跑起来啦。</li>
</ol>
<p>P.S. 由于<code>detachNewThreadSelector:toTarget:withObject</code>方法是一个类方法，所以他是直接开始运行你指定的内容，不会产生相应的对象</p>
<blockquote>
<p>小知识：查找了下，init和initWithTarget方法在iOS2.0以后才能被使用，而iOS 2.0是在08年的时候运用到iPhone上的，而OS X 10.5是在06年出生的，这也意味着苹果那时候都没想到多线程会变得那么常见~~（大雾）</p>
</blockquote>
<p>####修改状态<br>由于NSThread是轻量级的，所以我们可以直接对线程进行管理，所以就可以调用线程的sleep和cancel。</p>
<ul>
<li>休眠线程：<code>sleepUntilDate:</code>和<code>sleepForTimeInterval:</code>这两个一个是休眠到什么时候另一个是休眠多久（精确到毫秒）</li>
<li>退出线程：<code>exit</code>，这个是类方法，所以只能退出当前线程。</li>
<li>相对应的，苹果为了方便开发者的判断，也增加了<code>executing</code>,<code>finished</code>,<code>cancelled</code>这三个来查询线程的当前的状态。</li>
</ul>
<p>####常用属性</p>
<ul>
<li>threadDictionary:线程的字典用来存储一些有意义的内容</li>
<li>name:线程名字，可以更方便的区分线程。</li>
<li>stackSize:堆栈大小，这个只要知道就可以了。</li>
</ul>
<p>####优先级设置：<br>正如我们所提到的，多线程只是单核里面的多线程，所以设置优先级只能修改CPU对他调用的次数，这个无法解决线程同步的问题。</p>
<p>设置：<code>setThreadPriority:</code>方法<br>获得：<code>threadPriority</code>属性</p>
<p>###三、已存在的线程的调用<br>对于使用的线程使用（特别是主线程），在日常使用中也是比较频繁的使用的。而苹果提供了这几个API。</p>
<ol>
<li>获得主线程主线程：<code>mainThread</code></li>
<li>获得当前线程：<code>currentThread</code></li>
</ol>
<p>对应的苹果也提供了查询线程的属性，这很方便程序员来判断是否为当前线程或者主线程，从而更好对线程更好的处理。</p>
<p>###四、处理线程同步产生的读写问题<br>线程同步中最头疼的就是数据的重复从而产生的读写错误，在GCD中我们使用dispatch<em>barrier</em>*函数。在NSOperation中我们使用设置OperationQueue的最大处理的线程数，从而控制只有一条线程在处理数据。而NSThread，由于是对线程进行直接控制的，所以我们需要用其他方法来进行处理。</p>
<p>这里就使用三种：</p>
<ol>
<li>使用NSLock，也就是俗话所说的上锁。一般使用<code>[NSLockObject lock]</code>来上锁，用<code>[NSLockObject unlock]</code>来解锁。这个主要用来锁住你处理的代码块</li>
<li>使用NSCondition，这个方法和上面的NSLock相似，不过他可以使用<code>[NSConditionObj signal]</code>来唤醒其他线程中的<code>[NSConditionObj wait]</code>的方法，从而方便的控制两个或两个以上线程，从而更方便控制数据流。</li>
<li>使用@synchronized(anObj){code block}，anObj就是你需要锁住的对象，code block就是你需要锁住的区域。</li>
</ol>
<p>以上（包括前面两篇文章）就是所有iOS中的我们经常用到的多线程开发的简单介绍了。主要是为了自己能够有一个更好的总结，同时希望对各位看官有一定的帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
