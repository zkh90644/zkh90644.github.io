<!doctype html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/09/Socket-开发看这一篇就够了/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/09/Socket-开发看这一篇就够了/" itemprop="url">Socket 开发看这一篇就够了</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-09T19:53:42+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/04/译-Swift中的Weak，Strong和Unowned/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/04/译-Swift中的Weak，Strong和Unowned/" itemprop="url">[译]Swift中的Weak，Strong和Unowned</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T07:58:36+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我经常发现在我的代码中会出现循环引用的情况。我觉得别人也会出现这样的情况。虽然我不认识你，但是我相信在耳边肯定会经常出现“我什么时候要使用’weak’？如果我用’unowned’会有什么坑？”这篇文章我将会在其中写明如何在代码中使用strong, weak, unowned从而避免循环引用。但是我们可能都不知道如何使用他们。幸运的是，我将会告诉你他们都是些什么，什么时候应该是用他们。我希望这篇文章能够帮助你学习在什么情况下需要使用它们。</p>
<h2 id="让我们开始吧"><a href="#让我们开始吧" class="headerlink" title="让我们开始吧"></a>让我们开始吧</h2><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p><code>ARC</code> 是一个苹果用来自动管理内存的技术。他具体体现在 <em>Automatic Reference Counting.（自动引用计数）</em> 这意味着一个对象只有在没有强引用的时候才会被释放。</p>
<h3 id="STRONG"><a href="#STRONG" class="headerlink" title="STRONG"></a>STRONG</h3><p>让我们从什么是 Strong 开始吧。这本质上是一个很普通的引用（包括指针和其他的所有引用方法。）但是他的特殊点在于它能够 <strong><em>保护</em></strong> 被引用的对象在引用计数中一直有1个引用计数，从而防止被释放。但究其本质，<strong>和其他的别的一样</strong> 就是对一个对象有着强引用，这使得对象不被释放。这一点在接下去介绍循环引用的时候很重要。<br>强引用在 swift 中随处可见。实际上， Strong 是 swift 中的默认属性。对于内联对象中我们使用 strong 是安全的。对于一个对象的成员变量，一般我们也是使用强引用类型。</p>
<p>接下去就是一个强引用的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Kraken &#123;    let tentacle = Tentacle() //strong reference to child.&#125;</div><div class="line">class Tentacle &#123;    let sucker = Sucker() //strong reference to child&#125;</div><div class="line">class Sucker &#123;&#125;</div></pre></td></tr></table></figure>
<p>在上面的内敛代码中，<code>Kraken</code>有对于<code>Tentacle</code>的强引用，其中<code>Tentacle</code>对于<code>Sucker</code>有着强引用。这种强引用了从父对象<code>Kraken</code>流向了子对象<code>Sucker</code>（也就是说引用是连续的）<br>相同的，在动画的块中，引用关系也是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIView.animateWithDuration(0.3) &#123;    self.view.alpha = 0.0&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，<code>animationWIthDuration</code>是一个<code>UIView</code>的静态方法，其中的闭包块是父亲，而其中的self是孩子。</p>
<p>如果孩子当中也要引用父亲对象的话需要怎么办？接下来我们就要使<code>weak</code>和<code>Unowned</code>属性。</p>
<h2 id="WEAK-和-UNOWNED"><a href="#WEAK-和-UNOWNED" class="headerlink" title="WEAK 和 UNOWNED"></a>WEAK 和 UNOWNED</h2><h3 id="WEAK"><a href="#WEAK" class="headerlink" title="WEAK"></a>WEAK</h3><p>weak 引用只是一个指向那个对象的指针，但是他不会保护这个对象，所以当没有对象持有他的时候，他将会被 ARC 释放。如果这个对象被强引用，那么他的引用计数会加一，但是弱引用则不会。例外，弱引用的指针也会在对象成功释放的时候置零。这个时候如果你再去获得他的对象，会获得一个无效的对象或者nil。</p>
<p>在 swift 中，所有的弱引用都会作为<code>Optionals</code>（考虑一下 <code>var</code> 和 <code>let</code>的区别）因为这个引用应该 <strong>能</strong> 并且 <strong>将会</strong> 在没有对象持有他的时候置为nil。</p>
<p>接下来是个例子，代码不能进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Kraken &#123;    weak let tentacle = Tentacle() //let is a constant! All weak variables MUST be mutable.&#125;</div></pre></td></tr></table></figure></p>
<p>因为前缀是<code>let</code>。而<code>let</code>会使得这个对象在运行时（runtime）的情况下无法变化。因为weak的前缀的对象可能会使 nil ，所以 swift 的编译器中对于弱引用的变量需要使用<code>var</code>。</p>
<p>weak的弱引用主要使用的地方是用在你觉得有可能会出现 <strong>循环引用</strong> 的地方。一个循环发生在两个对象都 <strong>强引用</strong> 引用彼此的时候。如果两个对象都强引用着彼此的时候，ARC 将不会调用 <code>release</code> 的代码，因为两者都彼此没有释放。下图是苹果用来解释循环引用的插图。</p>
<p><img src="https://static1.squarespace.com/static/5592eb03e4b051859f0b377f/5594defde4b0ad11495b5c4e/5594defde4b0ad11495b5c80/1435819784267/retain-cycle-copy.png?format=1000w" alt="循环引用"></p>
<p>一个完美的体现循环引用的函数（相当新的）就是 <code>NSNotification</code> 的 APIs。让我们来看下下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Kraken &#123;</div><div class="line">    var notificationObserver: ((NSNotification) -&gt; Void)?</div><div class="line">    init() &#123;</div><div class="line">        notificationObserver = NSNotificationCenter.defaultCenter().addObserverForName(&quot;humanEnteredKrakensLair&quot;, object: nil, queue: NSOperationQueue.mainQueue()) &#123; notification in</div><div class="line">            self.eatHuman()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        if notificationObserver != nil &#123;</div><div class="line">            NSNotificationCenter.defaultCenter.removeObserver(notificationObserver)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中产生了循环引用。正如你所看到的，闭包就像 Objective-C 中的 block 。如果任何变量声明在 <strong>闭包范围之外</strong> ，引用 <strong>该范围内</strong> 的该变量将创建另一个对该对象的强引用。唯一的例外是使用价值语义的变量，例如 Swift 中的 Ints ， Strings ， Arrays 和 Dictionaries。</p>
<p>这里 <strong>NSNotificationCenter</strong> retain 了一个闭包并且在闭包中在调用 <code>eatHuman</code> 持有了 self 这个强引用。上面的代码中你在<code>deinit</code>方法中释放了消息通知这个成员变量，但是<code>deinit</code>不会被 ARC 调用，因为这个闭包里面调用了 <code>Kraken</code> 自身这个强应用。</p>
<p>另外的情况也会发生在 NSTimers 和 NSThread 里面。</p>
<p>而解决这个的办法就是对于闭包中的<code>self</code>这个对象使用弱引用进行引用。这将会打破强引用的循环。这样的话，我们的对象引用关系将会如下图所示：<br><img src="http://static1.squarespace.com/static/5592eb03e4b051859f0b377f/5594defde4b0ad11495b5c4e/5594defde4b0ad11495b5c7d/1435268855000/retain-cycle-broken.png?format=original" alt="weak &amp; strong"></p>
<p>改变成弱引用，不会增加弱引用的引用计数器，因此 ARC 将会在正确的时候将其释放。</p>
<p>如果需要在闭包中使用<code>weak</code>和<code>unowned</code>，你需要使用中括号([])在闭包的内部。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let closure = &#123; [weak self] in</div><div class="line">    self?.doSomething() //Remember, all weak variables are Optionals!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么要在使用 weak 的时候使用中括号语法？这看起来十分诡异！在 swift 中我们只有在数组中看到中括号。让我们猜一下？你可以在闭包中指定多个捕获值。<br>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let closure = &#123; [weak self, unowned krakenInstance] in //Look at that sweet Array of capture values.</div><div class="line">    self?.doSomething() //weak variables are Optionals!</div><div class="line">    krakenInstance.eatMoreHumans() //unowned variables are not.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这看起来和数组很像对吧？现在你知道为什么捕获值在方括号中。所以现在让我们继续学习，我们能够修复消息中的代码的循环引用了。我们可以将<code>[weak self]</code>加入闭包的捕获列表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSNotificationCenter.defaultCenter().addObserverForName(&quot;humanEnteredKrakensLair&quot;, object: nil, queue: NSOperationQueue.mainQueue()) &#123; [weak self] notification in //The retain cycle is fixed by using capture lists!</div><div class="line">    self?.eatHuman() //self is now an optional!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外我们需要使用弱引用的时候就是在 <strong>类</strong> 使用协议的使用委托中。在 swift 中，因为类使用引用语义。在 swift 中，结构体和枚举类型也能遵守协议。但是他们使用引用语义。如果一个父类使用了代理，那么他的成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Kraken: LossOfLimbDelegate &#123;</div><div class="line">    let tentacle = Tentacle()</div><div class="line">    init() &#123;</div><div class="line">        tentacle.delegate = self</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func limbHasBeenLost() &#123;</div><div class="line">        startCrying()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protocol LossOfLimbDelegate &#123;</div><div class="line">    func limbHasBeenLost()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Tentacle &#123;</div><div class="line">    var delegate: LossOfLimbDelegate?</div><div class="line"></div><div class="line">    func cutOffTentacle() &#123;</div><div class="line">        delegate?.limbHasBeenLost()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后你需要使用 weak。在这个例子中 Tentacle 通过代理强引用了 Kraken，而在 Kraken 中使用了一起强引用了他的成员变量 Tentacle。我们通过弱引用，使得他的代理定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weak var delegate:LossOfLimbDelegate?</div></pre></td></tr></table></figure>
<p>大声告诉我你想说啥？做了这个你就不能编译了？！好吧，这个问题是因为一个没有类的类型的代理不能够使用 weak 来进行表示。</p>
<p>为了解决这个问题，我们不得不使用一个class协议来修饰我们的代理就像我们协议的内敛<code>:class</code>来进行修饰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol LossOfLimbDelegate: class &#123; //The protocol now inherits class</div><div class="line">    func limbHasBeenLost()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们什么时候需要使用<code>:class</code>,<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID281" target="_blank" rel="external">苹果</a>给出的解释如下:</p>
<blockquote>
<p>”当该协议的要求定义的行为假定或要求符合类型具有引用语义而不是值语义时，请使用类专用协议”</p>
</blockquote>
<p>本质上，如果你使用了有层次结构的引用，你使用<code>:class</code>。但是对于结构体和枚举类型，你就不需要使用<code>:class</code>，因为结构体和枚举类型是值类型而类是引用类型。</p>
<h3 id="UNOWNED"><a href="#UNOWNED" class="headerlink" title="UNOWNED"></a>UNOWNED</h3><p><code>Weak</code>和<code>Unowned</code>引用很像，但是他们还是不一样的。所以说 Unowned 引用和 Weak 引用很像。Unowned 不会增加引用计数，在 Swift 中，Unowned 引用意味着对应的类型 <strong>不可能为 Optional 类型</strong>。这使得人们更简单的去管理而不需要重新去判断是否是一个optoin类型。这不像<a href="http://www.krakendev.io/when-to-use-implicitly-unwrapped-optionals/" target="_blank" rel="external">这里面所说的</a>。另外，<code>Unowned</code>引用是不会置零。这意味着当对象呗释放的时候，他不会不会亲历指针。这意味着使用 <code>Unowned</code> 会导致<a href="https://www.blackhat.com/presentations/bh-usa-07/Afek/Whitepaper/bh-usa-07-afek-WP.pdf" target="_blank" rel="external">野指针</a>的存在。对于像我一样已经用过 Objective-C 的人来说，<code>unowned</code>映射到 <code>Objective-C</code> 上面就像 <code>unsafe_unretained</code>。</p>
<p>现在你可能过一点疑惑。weak 和 unowned 这两个都不会增加引用计数，但是他们都会解决循环引用的问题，那么我们需要在什么时候使用他们呢？！<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" target="_blank" rel="external">苹果的文档</a>是这么介绍的：</p>
<blockquote>
<p>weak 在某个生命周期中的某个时刻是有效的。但是如果你知道设置了这个变量后，他永远都不会为0，那么请使用 unowned</p>
</blockquote>
<p>那你读过这类文章，就像<a href="http://www.krakendev.io/when-to-use-implicitly-unwrapped-optionals/" target="_blank" rel="external">这篇文章</a>。如果你能够保证引用不会置空，那么请使用 unowned 否则请使用 weak。</p>
<p>这里有一个很好的例子，里面的闭包里面存在循环引用。但是其中的 self 引用永远不可能为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class RetainCycle &#123;</div><div class="line">    var closure: (() -&gt; Void)!</div><div class="line">    var string = &quot;Hello&quot;</div><div class="line"></div><div class="line">    init() &#123;</div><div class="line">        closure = &#123;</div><div class="line">            self.string = &quot;Hello, World!&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Initialize the class and activate the retain cycle.</div><div class="line">let retainCycleInstance = RetainCycle()</div><div class="line">retainCycleInstance.closure() //At this point we can guarantee the captured self inside the closure will not be nil. Any further code after this (especially code that alters self&apos;s reference) needs to be judged on whether or not unowned still works here.</div></pre></td></tr></table></figure>
<p>在这种情况下，循环引用是因为闭包中捕获了了 self 并强引用了他，并将其作为自己的一个闭包属性。为了打破这个循环引用，我们使用<code>[unowned self]</code>。<br>加入闭包中的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">closure = &#123; [unowned self] in</div><div class="line">    self.string = &quot;Hello, World!&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这种情况下，我们能够保证 self 永远不为空，在我们创建了 循环引用的类之后，我们就会立刻调用闭包中的代码。</p>
<p>苹果是这么解释 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID57" target="_blank" rel="external">Unowned 引用</a></p>
<blockquote>
<p>当封闭和捕获的实例将始终引用时，将闭包中的捕获定义为一个 Unowned ，并且这个变量将始终在同一时间被释放。</p>
</blockquote>
<p>如果你知道你的引用将会清空，同时对这个变量的多次依赖彼此都是互相依赖。（其中的一个在另一个不存在的时候无法保留）那么你最好使用 Unowned 而不是 weak。因为你不会处理这些非必要的引用并将引用指针置空。</p>
<p>对于最简单的或者说最好的地方来使用 Unowned。是在闭包中通过懒定义就像下面的代码一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Kraken &#123;</div><div class="line">    let petName = &quot;Krakey-poo&quot;</div><div class="line">    lazy var businessCardName: () -&gt; String = &#123; [unowned self] in</div><div class="line">        return &quot;Mr. Kraken AKA &quot; + self.petName</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中我们需要使用 Unowned 来阻止循环引用。<code>Kraken</code> 这个类在他的生命周期中持有了 <code>businessCardName</code> 这个成员变量的闭包，同时 <code>businessCardName</code> 在他的生命周期中也持有了 <code>Kraken</code> 的 self 这个变量。他们是彼此依赖的，所以他们就会同时被释放。因为这是最满足 Unowned 的规则。</p>
<p>然而，这样的情况下我们 <strong><em>不需要</em></strong> 考虑是否需要在这样的懒加载的情况中加入 unowned。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Kraken &#123;</div><div class="line">    let petName = &quot;Krakey-poo&quot;</div><div class="line">    lazy var businessCardName: String = &#123;</div><div class="line">        return &quot;Mr. Kraken AKA &quot; + self.petName</div><div class="line">    &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[unowned self] 在这里是不需要的，因为对于懒加载的变量。他不会被 retains。（译者注：因为前面的是闭包，而这个是在创建 String 的闭包中）该变量在第一次调用结束后，自己控制内存的分配和释放。（同时自己管理了自己的引用计数。）下图是我调用它的一个截图。这个截图来自评论区的 <code>Алексей</code>。</p>
<p><img src="https://static1.squarespace.com/static/5592eb03e4b051859f0b377f/t/55cba3aae4b04e605ee3065f/1439409067643/?format=2500w" alt="String"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>循环引用，在我们日常的代码过程中需要十分注意，并且要考虑到底要使用哪一种引用。其中内存的泄露和释放内存可以通过 weak 和 Unowned 来进行避免。我希望这篇文章对你的成长有一定的帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/译-使用CommonCrypto进行AES的正确加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/28/译-使用CommonCrypto进行AES的正确加密/" itemprop="url">[译]使用CommonCrypto对文字进行AES的加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T22:51:55+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="译-使用-CommonCrypto-对文字进行AES的加密"><a href="#译-使用-CommonCrypto-对文字进行AES的加密" class="headerlink" title="[译]使用 CommonCrypto 对文字进行AES的加密"></a>[译]使用 CommonCrypto 对文字进行AES的加密</h2><p>原文链接:<a href="http://robnapier.net/aes-commoncrypto" target="_blank" rel="external">点我跳转</a></p>
<blockquote>
<p>译者注：由于需要写一个基于 SOCKS 5 协议的代理软件，所以免不了对 SOCKS 5 协议的加密方式有一定的了解，这篇文章就是译者在翻阅读物中找到的不错的文章，希望能和大家分享。<br>CommonCrypto 是一个 Mac 中自带的加密库，专门用来对相关的内容进行加密。</p>
</blockquote>
<p>更新1：你现在可以从我的 <a href="https://github.com/rnapier/ios5ptl/tree/master/ch11/CryptPic/CryptPic" target="_blank" rel="external">github</a> 下载文章中所有的源代码。</p>
<p>更新2：以下的内容，除非你想尝试去用你自己方式实现，否则你可以通过一个个很简单的方法，接入<a href="https://github.com/RNCryptor/RNCryptor" target="_blank" rel="external">RNCryptor</a>来自动的实现。</p>
<p>我翻阅了很多使用<code>CCCrypt()</code>的小例子，但是不幸的是，其中大多数都是错误的，在我完成了我将要出版的书的前10章的时候，我认为我需要需要写一篇短文来帮助人们来搞清楚这些东西。这就像小旋风一样，但是这只是一些简单的小例子。如果你想要更加清楚的其中的内容。你可以在今年晚些的时候阅读<a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-1119961327.html" target="_blank" rel="external">这本书</a>来获得相关的内容.(微笑脸)</p>
<p>在这当中最主要也必须写在前面的，就这秘钥。因为这在互联网上搜索相关的内容的过程中，所找到的内容总是错的。因为人们输入的不是一个AES的秘钥，因为秘钥中的熵差总是实在是太小了。直接把它作为 AES 的秘钥会导致你受到各种各样的攻击。特别是按照下面的代码来设置秘钥，这都是错误的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// DO NOT DO THIS</div><div class="line">NSString *password = @&quot;P4ssW0rd!&quot;;</div><div class="line">char keyPtr[kCCKeySizeAES128];</div><div class="line">[password getCString:keyPtr maxLength:sizeof( keyPtr ) encoding:NSUTF8StringEncoding];</div><div class="line">// DO NOT DO THIS</div></pre></td></tr></table></figure>
<p>这样设置秘钥容易收到很多攻击。同时他也不能应对一些频繁的变化。如果<code>密码</code>比秘钥还要长，那么加密后的密码将会被缩短。这就是为什么你需要设置一个正确的秘钥的重要性。</p>
<p>首先你得<code>**</code>你的秘钥，这意味着你需要将一个随机数据加入到秘钥中，因此如果你将相同的数据使用相同的密码进行加密，最终产生的结果也是不一样的。再加入随机数组后，你需要对秘钥进行哈希化，这样最终获得结果肯定能够获得对应的长度。而做这个最正确的方法就是使用<code>PKCS #5(PBKDF2)</code>不幸的是，在 Mac OS X 10.7 之前，没有一个简单的方法来加密。所以在下面的代码中，都会建立在 10.7 以后。但是如果你想要一个简单的解决方法。只要增加8个随机字符到字符串中，同时调用 <code>hash</code> 函数。在那之后再调用一次 <code>hash</code> 加密，这样重复 100,000 次。取秘钥中较低 “X” 位。虽然这不是很完美，但是这是一个简单的方法来编码实现它。在 MacBook Pro 的 Mac OS X 上面将花费 100ms，在相同时间的情况下 iPhone 4 上面大概只能实现 10,000 次。这个这目的只是为了让攻击者能够花费更多的时间来破解。</p>
<p>（如果你有更好的或者更加快速且简单的加密方法，请在下面留言）</p>
<p>但是就像我所说的，你不需要这么做，因为 <code>PBKDF2</code> 已经加入到 <code>CommonCrypto</code>(在iOS 10.7之后)。在进行混淆之后，你的密码和你秘钥的长度都会产生，先别着急写代码。在接下去的内容，我讲告诉你如何去进行编码。</p>
<p>我没提到过 <code>CommonCrypto</code> 是一个<a href="http://opensource.apple.com/source/CommonCrypto" target="_blank" rel="external">开源</a>的么？所以如果你希望在其他平台上使用 <code>PBKDF2</code>，你可以通过源码来了解他的实现方式。</p>
<p>好了，现在你已经混淆了他，接下来我们要做什么？把密文保存下来，因为之后你可能需要对它进行解密。已经被混淆了的数据会被认为是公共信息，所以你不需要保护他。</p>
<p>大家可能会对神秘的初始化向量（IV）(前缀的字符串)感到迷惑。在 CBC模式 下每16个字节进行加密后会影响后面16个字节的加密。这很棒，这使得我们的加密更加安全有效。而且这种情况是默认的。但是其中的问题就是。对于开始的那几个字符，我们怎么处理？解决方案就是使用随机块-1，那就是添加前缀字符串。</p>
<p>这个初始化向量在 <code>CCCrypt()</code> 函数中被列为可选的。这又会让人感到费解，因为真正的 CBC模式中的这个值是不可选的。如果你没有提供这个选项。他将会使用全为0的向量给你。这将会对第一个数据块进行保护，但是没有这个必要这么做。因为前缀字符串只是个简单的16个随机字节。“将这16个字节保存下来，因为接下来的解密中，你将会需要这段内容。这些内容也考虑到了公共信息，所以你不需要对他采取保护措施。”</p>
<p>好了现在我们将会继续我们的加密，让我们来看下下面的小练习。首先，你需要知道如何使用它。这个方法将会返回已经加密的数据（如果失败，那么返回nil）同时返回对应的前缀字符串的数据，混淆之后的内容和加密错误的错误信息的引用。将所有数据，IV，混淆的内容用一种你觉得简单的方法写到文件中。其中 IV 已经被 AES 加密，混淆的内容的长度可能会不一样，但是我的代码中，我都会将设置为8个字节长，因为这是 PKCS#5 需要的最小长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSData *iv;</div><div class="line">NSData *salt;</div><div class="line">NSError *error;</div><div class="line">NSData *encryptedData = [RNCryptManager encryptedDataForData:plaintextData</div><div class="line">            password:password</div><div class="line">                  iv:&amp;iv</div><div class="line">                salt:&amp;salt</div><div class="line">              error:&amp;error];</div></pre></td></tr></table></figure>
<p>然后接下来的代码。我将会把解密方法作为读者可以使用的一个练习，这些内容在一定意义上是共通的，你最好理解其中的代码，而不仅仅是简单的复制。不要忘记加入 Security.framework 这个库</p>
<p>接下来就是代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">#import &lt;CommonCrypto/CommonCryptor.h&gt;</div><div class="line">#import &lt;CommonCrypto/CommonKeyDerivation.h&gt;</div><div class="line"></div><div class="line">NSString * const</div><div class="line">kRNCryptManagerErrorDomain = @&quot;net.robnapier.RNCryptManager&quot;;</div><div class="line"></div><div class="line">const CCAlgorithm kAlgorithm = kCCAlgorithmAES128;</div><div class="line">const NSUInteger kAlgorithmKeySize = kCCKeySizeAES128;</div><div class="line">const NSUInteger kAlgorithmBlockSize = kCCBlockSizeAES128;</div><div class="line">const NSUInteger kAlgorithmIVSize = kCCBlockSizeAES128;</div><div class="line">const NSUInteger kPBKDFSaltSize = 8;</div><div class="line">const NSUInteger kPBKDFRounds = 10000;  // ~80ms on an iPhone 4</div><div class="line"></div><div class="line">// ===================</div><div class="line"></div><div class="line">+ (NSData *)encryptedDataForData:(NSData *)data</div><div class="line">                        password:(NSString *)password</div><div class="line">                              iv:(NSData **)iv</div><div class="line">                            salt:(NSData **)salt</div><div class="line">                           error:(NSError **)error &#123;</div><div class="line">  NSAssert(iv, @&quot;IV must not be NULL&quot;);</div><div class="line">  NSAssert(salt, @&quot;salt must not be NULL&quot;);</div><div class="line"></div><div class="line">  *iv = [self randomDataOfLength:kAlgorithmIVSize];</div><div class="line">  *salt = [self randomDataOfLength:kPBKDFSaltSize];</div><div class="line"></div><div class="line">  NSData *key = [self AESKeyForPassword:password salt:*salt];</div><div class="line"></div><div class="line">  size_t outLength;</div><div class="line">  NSMutableData *</div><div class="line">  cipherData = [NSMutableData dataWithLength:data.length +</div><div class="line">                kAlgorithmBlockSize];</div><div class="line"></div><div class="line">  CCCryptorStatus</div><div class="line">  result = CCCrypt(kCCEncrypt, // operation</div><div class="line">                   kAlgorithm, // Algorithm</div><div class="line">                   kCCOptionPKCS7Padding, // options</div><div class="line">                   key.bytes, // key</div><div class="line">                   key.length, // keylength</div><div class="line">                   (*iv).bytes,// iv</div><div class="line">                   data.bytes, // dataIn</div><div class="line">                   data.length, // dataInLength,</div><div class="line">                   cipherData.mutableBytes, // dataOut</div><div class="line">                   cipherData.length, // dataOutAvailable</div><div class="line">                   &amp;outLength); // dataOutMoved</div><div class="line"></div><div class="line">  if (result == kCCSuccess) &#123;</div><div class="line">    cipherData.length = outLength;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    if (error) &#123;</div><div class="line">      *error = [NSError errorWithDomain:kRNCryptManagerErrorDomain</div><div class="line">                                   code:result</div><div class="line">                               userInfo:nil];</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return cipherData;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ===================</div><div class="line"></div><div class="line">+ (NSData *)randomDataOfLength:(size_t)length &#123;</div><div class="line">  NSMutableData *data = [NSMutableData dataWithLength:length];</div><div class="line"></div><div class="line">  int result = SecRandomCopyBytes(kSecRandomDefault,</div><div class="line">                                  length,</div><div class="line">                                  data.mutableBytes);</div><div class="line">  NSAssert(result == 0, @&quot;Unable to generate random bytes: %d&quot;,</div><div class="line">           errno);</div><div class="line"></div><div class="line">  return data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ===================</div><div class="line"></div><div class="line">// Replace this with a 10,000 hash calls if you don&apos;t have CCKeyDerivationPBKDF</div><div class="line">+ (NSData *)AESKeyForPassword:(NSString *)password</div><div class="line">                         salt:(NSData *)salt &#123;</div><div class="line">  NSMutableData *</div><div class="line">  derivedKey = [NSMutableData dataWithLength:kAlgorithmKeySize];</div><div class="line"></div><div class="line">  int</div><div class="line">  result = CCKeyDerivationPBKDF(kCCPBKDF2,            // algorithm</div><div class="line">                                password.UTF8String,  // password</div><div class="line">                                [password lengthOfBytesUsingEncoding:NSUTF8StringEncoding],  // passwordLength</div><div class="line">                                salt.bytes,           // salt</div><div class="line">                                salt.length,          // saltLen</div><div class="line">                                kCCPRFHmacAlgSHA1,    // PRF</div><div class="line">                                kPBKDFRounds,         // rounds</div><div class="line">                                derivedKey.mutableBytes, // derivedKey</div><div class="line">                                derivedKey.length); // derivedKeyLen</div><div class="line"></div><div class="line">  // Do not log password here</div><div class="line">  NSAssert(result == kCCSuccess,</div><div class="line">           @&quot;Unable to create AES key for password: %d&quot;, result);</div><div class="line"></div><div class="line">  return derivedKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/05/如何编写高质量的Objective-C代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/05/如何编写高质量的Objective-C代码/" itemprop="url">如何编写高质量的Objective-C代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-05T15:26:10+08:00">
                2017-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文为《Effect Objective-C 2.0 编写高质量iOS与OS X代码的52个有效的方法》的读后感。由于书中的内容很多都是经典的案例，然而直接记住有一定的压力。所以将重点列在下面，方便后期回顾。</p>
</blockquote>
<h3 id="第一章-熟悉-Objective-C"><a href="#第一章-熟悉-Objective-C" class="headerlink" title="第一章 熟悉 Objective-C"></a>第一章 熟悉 Objective-C</h3><ol>
<li>Objective-C为C语言添加了面向对象这一个特性，是C的超集。由于动态绑定消息结构，只有在运行时候才会检查对象的类型，所以接收到消息后，会在运行期而非编译器时期来决定。（冠以动态绑定将在下面的后面详细介绍。）</li>
<li>改变头文件引用情况，从而改善依赖关系。<ul>
<li>方法：在不需要调用类内部对象的时候，直接使用<code>@class className</code>来取代<code>#import className.h</code></li>
<li>原因：<ul>
<li>在.h文件中尽可能减少不必要的头文件，一般如果只是为了加入某个类直接可以使用<code>@class className</code>来进行添加，否则容易产生循环import，在编译的时候编译器会报错。</li>
<li>对于保存在一个较大类中的 protocol ，可以将这个 protocol 单独放在一个文件中，以防引入类导致的编译时间的降低。</li>
</ul>
</li>
</ul>
</li>
<li>采用字面量来代替等价的方法。<ul>
<li>方法：<ul>
<li>NSString 对象创建采用<code>@&quot;this is a NSString Object&quot;;</code></li>
<li>NSArray 对象创建采用<code>@[obj1, obj2, obj3];</code></li>
<li>NSDictionary 对象创建采用<code>@{ key1 : obj1, key2 : obj2, key3 : obj3};</code></li>
</ul>
</li>
<li>原因：Objective-C 对于创建一些常用的对象给予了我们一些语法糖，从而更加简明扼要。</li>
<li>注意点：<ul>
<li>如果在创建的过程中如果有对象是nil的，那么会导致程序 crash。</li>
<li>产生的对象都是不可变的，也就是 immutable, 如果要创建对应的可变对象的话，需要使用<code>[object mutableCopy]</code></li>
</ul>
</li>
</ul>
</li>
<li><p>多用类型常量，少用#define</p>
<ul>
<li><p>方法：</p>
<ul>
<li><code>static const NSTimeInterval kAnimationDuration = 0.3f;</code>代替<code>#define ANIMATION_DURATION 0.3;</code></li>
<li><code>static NSString *const StringValue = @&quot;this is a string&quot;</code>代替<code>#define STRING_VALUE @&quot;this is a String&quot;</code></li>
<li>对于需要暴露给外部的属性命名如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Class.h</div><div class="line">extern NSString *const StringValue;</div><div class="line"></div><div class="line">// Class.m</div><div class="line">NSString *const StringValue = @&quot;this is a string&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原因：</p>
<ul>
<li>由于<code>#define</code>采用的是直接在<strong>预处理</strong>的过程中就把对应的内容进行替换。而在编写的过程中不会成功提醒。</li>
<li>这样能够清晰的描述所需要设置的类型。</li>
</ul>
</li>
<li>注意点：<ul>
<li>static 不能出现在 .h 文件中，因为在 .h 文件中使用了 static 也就意味着这个变量为全局变量。</li>
<li>const 是为了防止被修改而存在的。</li>
<li>对于不会改变的变量，使用 const</li>
<li>.m 文件中使用 static 进行修饰的意思就是每一份该变量的作用于只局限在该<strong>编译单元</strong>中。编译器每收到一份<strong>编译单元</strong>（一般是一个类的实现文件），那就会生成一份<strong>目标文件</strong>（.o文件）。如果没有使用 static 进行修饰，那么当编译器进行编译，如果别的类里面也使用了这个变量名，那么就会提示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _property in:</div><div class="line">  a.o</div><div class="line">  b.o</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对于状态码使用枚举类型。</p>
<ul>
<li><p>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, ValueStatu) &#123;</div><div class="line">  ValueAStatus,</div><div class="line">  ValueBStatus,</div><div class="line">  ValueCStatus,</div><div class="line">&#125;</div><div class="line">typedef NS_OPTION(NSUInteger, ValueOption) &#123;</div><div class="line">  ValueAOption = 1 &lt;&lt; 0,</div><div class="line">  ValueBOption = 1 &lt;&lt; 1,</div><div class="line">  ValueCOption = 1 &lt;&lt; 2,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
<ul>
<li>枚举类型可以更好地表达有限个的类型的意思。方便后期添加。</li>
<li>对于<code>NS_OPTION</code>这个类型，可以判断语句中直接使用 <code>ValueMyOption &amp; ValueBOption</code>来进行判断我所提供的变量是否包含了多个选项。</li>
<li>使用<code>typedef</code>而不是直接使用原有的<code>enum</code>是为了匹配各种编译器，因为苹果给我们在底层对相关内容进行了封装。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第二章-对象、消息、运行期（runtime）"><a href="#第二章-对象、消息、运行期（runtime）" class="headerlink" title="第二章 对象、消息、运行期（runtime）"></a>第二章 对象、消息、运行期（runtime）</h4><ol>
<li>理解“属性”这一概念<ul>
<li>方法：使用<code>@property (nonatomic, strong) *Class className</code>来代替直接使用<code>@public NSData *_data</code>。</li>
<li>原因：<ol>
<li>如果使用 JAVA、C++ 的创建对象的方法,编译在编译器计算偏移量，那么在修改这个类的定以后需要进行重新编译。</li>
<li>如果在2个属性中间加入了第三个属性，那么就会打乱原有的偏移量，如果其他代码还在调用这个偏移量，那么就会发生错误。</li>
<li>Objective-C 使用<code>类对象</code>对相关的内容进行管理，从而永远能够获得正确的偏移量。（在运行期的过程中向类中新增实例变量也可以正确获取。）这就是稳定的应用程序<strong>二进制接口</strong>(Application Binary Interface， ABI)</li>
</ol>
</li>
<li>注意点：<ul>
<li>使用<code>@property</code>来声明变量，编译器会在<strong>编译期</strong>自动帮你创建 setter 方法和 getter ，这个过程叫做“自动合成（autosynthesis）”，同时对于这个属性，会生成对应的<strong>实例变量</strong>。同时 Objective-C 中延续了 C 中 struct 的语法糖，对于属性可以直接使用<strong>点语法</strong>获得对应的实例变量。</li>
<li>你可以使用<code>@synthesize</code>来手动创建对应的实例变量的名字，默认编译器会自动帮你创建实例变量的名字，一般是原有名字前面加上<code>下划线(_)</code></li>
<li>对于如果你不想让编译器自动帮你创建 setter 或 getter 方法，你直接手动创建即可，但是如果你不想让编译器帮你创建 setter 和 getter 方法，那么就需要在 implementation 中使用<code>@dynamic</code>来声明对应的属性。</li>
</ul>
</li>
</ul>
</li>
<li>属性的特质<br>在前面的<code>@property (nonatomic, strong) *Class className</code>中，括号内，有2个特质，这两个特质表示了这个属性有哪些特性。而这些特质我们分为4类<ul>
<li>原子性：<ul>
<li>atomic（default），原子性，表示该属性在读写时候会加上同步锁，从而防止读取脏数据的可能性。但是极大的影响性能。</li>
<li>nonatomic，非原子性，表示该属性在一般情况下有可能会读取到脏数据。</li>
</ul>
</li>
<li>读/写权限。<ul>
<li>readwrite （default），具有读写特质，如果使用了<code>@synthesize</code>说明编译器会自动帮你创建对应的读写方法。</li>
<li>readonly， 只读属性，如果使用了<code>@synthesize</code>说明编译器会自动帮你创建读取方法。</li>
</ul>
</li>
<li>内存管理语义<ul>
<li>assign（default），只会针对“纯量类型”，比如说<code>CGFloat</code>,<code>NSInteger</code>等等。</li>
<li>strong，表示了一种“拥有关系”，设置新值的时候，会保留新值，释放旧值。</li>
<li>weak，表示了一种“非拥有关系”，设置新值的时候，不会保留新值，也不会保留旧值，如果他指向的对象被释放，他就会置 nil 。（实现原理类似于写一个字典中，然后根据字典中的 key ，来获得他的 value ，从而确定是否需要置为空）</li>
<li>unsafe_unretained，表示了一种“非拥有关系”,他和 weak 类似，不过在目标被摧毁的时候，他不会置空，所以是不安全的。</li>
<li>copy，这个特性和 strong 相似，不过他在创建新值的时候不会保留新值，而是创建一份新值的拷贝（copy），但是这个时候，他创建的是新值是不可变的（即不是MutableCopy）。</li>
</ul>
</li>
<li>方法名<ul>
<li>getter=<name>，指定对应的getter方法名，比如说<code>@property (nonatomic, getter=isOn) BOOL on;</code>这样他的 getter 方法就是<code>isOn</code>，从而在调用的时候更加明白。</name></li>
<li>setter=<name>，一般很少去实现这个方法。实现 setter 方法可能会导致程序出现 Bug。</name></li>
<li>注意：在赋值语句的时候，最好直接使用实例变量进行赋值。因为这样防止因为 setter 方法发生改变导致的问题。同时，如果属性是<code>readonly</code>那么他就没有<code>setter</code>方法这样做会导致使用setter方法失败。</li>
</ul>
</li>
<li>注意点：在iOS开发中，因为性能原因，所以我们一般使用 nonatomic ，而在 OS X 中进行开发的时候，我们使用 atomic 一般也不会遇到瓶颈。</li>
</ul>
</li>
<li>初始化的过程中尽可能使用实例变量进行访问。<ul>
<li>使用实例变量来获得对应的实例变量进行赋值速度更快</li>
<li>使用实例变量不会调用 setter 方法，如果该属性是 copy 方法，那么就不会触发 copy 方法，只会保留新值并释放旧值。</li>
<li>使用实例变量不会触发 KVO 通过属性来访问，可以方便的使用断点来找到对应的那个属性的时机。</li>
<li>在对象内部的时候，读取使用实例变量，赋值使用属性。</li>
<li>对于懒加载，需要使用属性进行调用，从而创建实例变量。</li>
</ul>
</li>
<li><p>对象等同性。</p>
<ul>
<li>方法：使用 <code>isEqual</code> 来保证两个对象是相同的。</li>
<li><p>原因：</p>
<ul>
<li>因为直接 == 比较的是两个指针本身。</li>
<li>NSObject 类的协议中用两个判断相同的方法使用<code>isEqual</code>和<code>hash</code>。默认是两个指针值相同才返回真。</li>
<li>对于某个对象，我们使用下面代码来返回他的哈希值（哈希值相同，两个对象不一定相同）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)hash &#123;</div><div class="line">  NSUInteger firstNameHash = [_firstName hash];</div><div class="line">  NSUInteger lastNameHash = [_lastName hash];</div><div class="line">  NSUInteger ageHash = _age;</div><div class="line"></div><div class="line">  return firstNameHash ^ lastNameHash ^ age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注意：一般对于特定类的相等的描写：</p>
<ol>
<li>首先判断指针是否相等。</li>
<li>然后判断类是否相等</li>
<li>然后判断值是否相等。</li>
<li>容器相同性：{(1,2)}-&gt;{(1),(1,2)}-&gt;{(1,2),(1,2)}-&gt;copy-&gt;{(1,2)}</li>
</ol>
</li>
</ul>
</li>
<li>以“类族模式”隐藏实现细节。<ul>
<li>方法：子类继承父类，父类在创建方法中使用枚举来返回不同子类的类型，同时将绘制逻辑放到父类中实现。</li>
<li>原因：基于Objective-C不是强制类型，隐藏实现方法，使得调用更加简单，更加清晰。</li>
</ul>
</li>
<li>在既有类中使用关联对象存放自定义数据。<ul>
<li>方法：引入<code>&lt;objc/runtime.h&gt;</code>,然后调用<code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code>，<code>id objc_getAssociatedObject(id object, void *key)</code>，<code>void objc_removeAssociatedObject(id object)</code>三个方法来创建，调用，删除关联自定义数据。</li>
<li>原因：更易读懂，无需在代码块中来回游走。</li>
<li>注意点：<ul>
<li>关联类型种类包括 assign, nonatomic, atomic, retain, copy, retain, copy。</li>
<li>不能大量使用，否则容易导致代码失控。</li>
<li>该方法是最后解，即用其他方法无法实现的时候才会使用这个方法。</li>
</ul>
</li>
</ul>
</li>
<li>理解objc_msgSend的作用<ul>
<li>方法：使用<code>id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter)</code>，其中someObject是接受者，@selector(messageName:)是选择子。这样返回的是是一个id对象。同理存在<code>objc_msgSend_stret（返回struct）</code>,<code>objc_msgSend_fpret(返回浮点数)</code>，<code>objc_msgSendSuper（给id对象的超类发送信息。）</code></li>
<li>原因：Objective-C 是一门动态语言，objc_msgSend 就是发送去查找“方法列表”（每个类都有自己的方法列表，同时在查找完之后会保存在这个类自己的快速映射表，方便下次查找）并调用相关函数，如果没有调用到，那么就会沿着继承体系去进行查找，如果最后还是没有，那么就使用转发操作。</li>
<li>具体表现：<strong>尾调用优化（tail-call optimization）</strong></li>
</ul>
</li>
<li>消息转发机制<ul>
<li>使用方法：</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/26/iOS网络编程（二）IP、DNS相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/26/iOS网络编程（二）IP、DNS相关/" itemprop="url">iOS网络编程（二）IP、DNS相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-26T23:57:27+08:00">
                2017-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>由于要实现一个VPN首先要开手机中开启一个服务，而 iOS 基于 linux 那么很明显，我们需要了解 Linux 下的相关函数，从而更好地创建服务，而 Linux 底层是基于 C 和 C++，而 iOS 中无论是 swift 还是 Objective-C 都可以完美的兼容 C，所以了解 C 的相关函数，对于我们开发是有很大的帮助的</p>
</blockquote>
<h3 id="网络编程——DNS基本知识"><a href="#网络编程——DNS基本知识" class="headerlink" title="网络编程——DNS基本知识"></a>网络编程——DNS基本知识</h3><ol>
<li><p>常见 DNS 资源<br>|       代码      |     号码       |      描述       |        介绍     |<br>| :————- | :————- | :————- | :————- |<br>| A              | 1              | IP 地址记录        | 传回一个 32 比特的 IPv4 地址，最常用于映射主机名称到 IP地址，但也用于DNSBL（RFC 1101）等。|<br>| AAAA           | 28             | IPv6 IP 地址记录 | 传回一个 128 比特的 IPv6 地址，最常用于映射主机名称到 IP 地址。|<br>| CNAME          | 5              | 规范名称记录      | 一个主机名字的别名：网域名称系统将会继续尝试查找新的名字。|</p>
<p>如果想要更加形象的了解相关的内容，比如说一个人叫做老王，那么CName就是王XX（老王的真名），A就是他所住的地址，AAAA就是他所住地址用英文表示。<br>你在 linux 下面可以使用 dig 命令来对对应的主机进行请求。<br>比如说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ dig www.google.com -t a</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.google.com -t a</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45402</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"></div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.google.com.			IN	A</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">www.google.com.		1257	IN	A	93.46.8.89</div><div class="line"></div><div class="line">;; Query time: 11 msec</div><div class="line">;; SERVER: 192.168.1.1#53(192.168.1.1)</div><div class="line">;; WHEN: Fri Jan 27 00:26:45 2017</div><div class="line">;; MSG SIZE  rcvd: 48</div></pre></td></tr></table></figure>
<p>这样可以获得谷歌的IPv4情况下的地址是 93.46.8.89</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ dig www.google.com -t aaaa</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.google.com -t aaaa</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51370</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"></div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.google.com.			IN	AAAA</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">www.google.com.		2350	IN	AAAA	200:2:5d2e:859::</div><div class="line"></div><div class="line">;; Query time: 8 msec</div><div class="line">;; SERVER: 192.168.1.1#53(192.168.1.1)</div><div class="line">;; WHEN: Fri Jan 27 00:26:37 2017</div><div class="line">;; MSG SIZE  rcvd: 60</div></pre></td></tr></table></figure>
<p>这样可以获得谷歌的IPv6情况下的地址是 200:2:5d2e:859::</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ dig www.baidu.com -t cname</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.baidu.com -t cname</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64206</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"></div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.baidu.com.			IN	CNAME</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">www.baidu.com.		481	IN	CNAME	www.a.shifen.com.</div><div class="line"></div><div class="line">;; Query time: 7 msec</div><div class="line">;; SERVER: 192.168.1.1#53(192.168.1.1)</div><div class="line">;; WHEN: Fri Jan 27 00:25:01 2017</div><div class="line">;; MSG SIZE  rcvd: 58</div></pre></td></tr></table></figure>
<p>这样可以获得百度的CNAME的地址是 www.a.shifen.com.，也就是说所有你请求 www.baidu.com 最终都会转移到 www.a.shifen.com 上面。</p>
<p>当某一个参数没有配置的情况下，他会根据已经配置的优先级，返回对应的内容。比如说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ dig www.baidu.com -t aaaa</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.baidu.com -t aaaa</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 21726</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 0</div><div class="line"></div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.baidu.com.			IN	AAAA</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">www.baidu.com.		492	IN	CNAME	www.a.shifen.com.</div><div class="line"></div><div class="line">;; AUTHORITY SECTION:</div><div class="line">a.shifen.com.		94	IN	SOA	ns1.a.shifen.com. baidu_dns_master.baidu.com. 1701250009 5 5 86400 3600</div></pre></td></tr></table></figure>
<p>如果你想要快速获得a和cname，你可以直接通过 ping 来进行获取，从而获得对应的内容，例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ping www.baidu.com</div><div class="line">PING www.a.shifen.com (115.239.211.112): 56 data bytes</div><div class="line">64 bytes from 115.239.211.112: icmp_seq=0 ttl=55 time=11.128 ms</div><div class="line">--- www.a.shifen.com ping statistics ---</div><div class="line">1 packets transmitted, 1 packets received, 0.0% packet loss</div><div class="line">round-trip min/avg/max/stddev = 11.128/11.128/11.128/0.000 ms</div></pre></td></tr></table></figure>
</li>
<li><p>常用结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public struct hostent &#123;</div><div class="line">  public var h_name: UnsafeMutablePointer&lt;Int8&gt;! /* 主机规范名字 */</div><div class="line">  public var h_aliases: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;! /* 主机别名 */</div><div class="line">  public var h_addrtype: Int32 /* AF_INET/AF_INET6 */</div><div class="line">  public var h_length: Int32 /* 4/16 */</div><div class="line">  public var h_addr_list: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;! /* 服务器地址链表 */</div><div class="line">  public init()</div><div class="line">  public init(h_name: UnsafeMutablePointer&lt;Int8&gt;!, h_aliases: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, h_addrtype: Int32, h_length: Int32, h_addr_list: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public struct in_addr &#123;</div><div class="line">  public var s_addr: in_addr_t  //用来表示一个32位的IPv4地址，即用字节类型来记录ip地址，例如192.168.3.144记为0x9003a8c0，顺序为IP地址的逆序，即c0为192,a8为168,03为3,90为144</div><div class="line">  public init()</div><div class="line">  public init(s_addr: in_addr_t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络编程——DNS常见函数"><a href="#网络编程——DNS常见函数" class="headerlink" title="网络编程——DNS常见函数"></a>网络编程——DNS常见函数</h3><ol>
<li><code>public func gethostbyname(_: UnsafePointer&lt;Int8&gt;!) -&gt; UnsafeMutablePointer&lt;hostent&gt;!</code>:如果没有设置<code>RES_USE_INET6</code>则查找A的记录，如果找到则返回 hostent ，否则返回错误，如果设置了，那么先查找 AAAA ，如果没有找到再查找 A 的记录</li>
<li><code>public func gethostbyname2(_: UnsafePointer&lt;Int8&gt;!, _: Int32) -&gt; UnsafeMutablePointer&lt;hostent&gt;!</code>:功能同上，不过第二个参数是增加查找情况，如果传入值是<code>AF_INET</code>那么查找的是为A的记录，如果没有则返回空，如果找到了，查看有没有设置<code>RES_USE_INET6</code>，如果没有设置，那么就返回 IPv4 的地址，若设置了则返回 IPv4 地址到 IPv6 地址的映射。如果设置为<code>AF_INET6</code>，那么查找为AAAA的记录，如果找到了就返回，否则返回空字符串。(<code>RES_USE_INET6</code>必须在调用这几个函数前进行设置)</li>
</ol>
<h3 id="网络变成——IP常见函数"><a href="#网络变成——IP常见函数" class="headerlink" title="网络变成——IP常见函数"></a>网络变成——IP常见函数</h3><ol>
<li><code>public func inet_ntop(_: Int32, _: UnsafeRawPointer!, _: UnsafeMutablePointer&lt;Int8&gt;!, _: socklen_t) -&gt; UnsafePointer&lt;Int8&gt;!</code>：IP地址的点分二进制-&gt;点分十进制的转化。</li>
<li><code>public func inet_pton(_: Int32, _: UnsafePointer&lt;Int8&gt;!, _: UnsafeMutableRawPointer!) -&gt; Int32</code>：IP地址的点分十进制-&gt;点分二进制的转化。</li>
</ol>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul>
<li><a href="http://blog.csdn.net/youkuxiaobin/article/details/6954418" target="_blank" rel="external">第九章 基本名字和地址转换</a></li>
<li><a href="http://blog.csdn.net/xiexingshishu/article/details/39802967" target="_blank" rel="external">网络编程学习笔记(RES_USE_INET6解析器选项)</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/26/iOS网络编程（一）网络编程基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/26/iOS网络编程（一）网络编程基础/" itemprop="url">iOS网络编程（一）网络编程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-26T23:27:55+08:00">
                2017-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于iOS 9以后苹果开放了<code>Network Extension</code>这个互联网的库，而我自己也想做一个VPN，在互联网上对相关的资料进行搜索，比如说<a href="https://github.com/zhuhaow/Specht" target="_blank" rel="external">Specht</a>和该作者的数据传输库<a href="https://github.com/zhuhaow/NEKit" target="_blank" rel="external">NEKit</a>等相关资料的搜索，在这对VPN开发进行一个总结或者学习的归纳。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>虽然苹果开放了<code>Network Extension</code>这个库，但是这只是方便了我们能够方便的创建一个代理，但是相对的，对应tunnel-&gt;socket的转换还是需要我们自己进行处理的。</li>
<li>简单而已，根据同事的介绍，苹果的VPN就是在手机中开启了一个服务，然后所有的流量都是通过这个服务进行区分发送，这样就能将手机中所有请求都根据我们自己的配置进行设置。</li>
<li>苹果开放了3个主要的类型 <code>Network Extension Entitlement</code>、<code>Personal VPN</code>、<code>Network Tunneling Protocol Client</code>，而对于我们而言，需要创建的就是<code>Network Tunneling Protocol Client</code>，第二个<code>Personal VPN</code>基于的是<code>IPSec</code>协议和<code>IKEv2</code>协议，这里和我的需求不符合，所以暂时不在考虑范围内。而第一个<code>Network Extension Entitlement</code>目的是方便 wifi 连接，也不在我们的考虑范围内，所以也不作考虑。</li>
<li>苹果在2016-11-10之后对于 apple developer 开放了<code>Network Extension</code>权限（原来需要进行邮件申请，填写好所有你想要获得的信息后，他才会给你一个反馈）。现在只需要在apple developer中创建<code>Provisioning Profiles</code>和<code>Identifiers</code>中的<code>App IDs</code>从而允许对应的app可以使用网络库。</li>
</ol>
<h3 id="网络编程——网络基础"><a href="#网络编程——网络基础" class="headerlink" title="网络编程——网络基础"></a>网络编程——网络基础</h3><ol>
<li>完全限定域名（英语：Fully qualified domain name），<blockquote>
<p>缩写为FQDN，又译为完全资格域名、完整领域名称，又称为绝对领域名称（absolute domain name）、 绝对域名，网域名称的一种，能指定其在域名系统 (DNS) 树状图下的一个确实位置。一个完全资格域名会包含所有域名级别，包括 顶级域名 和 根域名。完整网域名称这个名称的由来，是因为它没有模糊空间，只能用一种方式来解析。完整网域名称是因应互联网上需要一个统一识别方式而出现，在1980年代后期快速成长。<br>完整网域名称由主机名称与母网域名称两部分所组成，例如有一部服务器的本地主机名为myhost，而其母域名为example.com，那指向该服务器的完整网域名称就是myhost.example.com。虽然世界上可能有很多服务器的本地主机名是myhost，但myhost.example.com是唯一的，因此完整网域名称能识别该特定服务器。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/31/Re从零开始创建基于cocoapods的第三方库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/31/Re从零开始创建基于cocoapods的第三方库/" itemprop="url">Re:从零开始创建基于cocoapods的第三方库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-31T18:42:30+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有句俗话这么说道</p>
<blockquote>
<p>万物始于git</p>
</blockquote>
<p>而 iOS 自从存在了 cocoapods 这一神器之后，就再也不用继续使用 submodule 这一坑爹货了。（虽然 cocoapods 也基于强大的 git ）</p>
<p>而对于初学者来说，我们只要学会简单的是用<code>pod install</code>对第三方库进行引用。</p>
<p>而对进阶者来说，我们不仅仅需要学会如何去使用它，更重要的是学会如何去创建一个 cocoapods。</p>
<p>以前的我，傻傻的写完整个工程，然后再创建 podspec，然后再添加对应的代码到新的工程之中，这很明显很傻。但是自从 cocoapods 升级到了 1.0.0 以后，它提供了一个命令，帮助我们一键生成所需要的工程。</p>
<p>这就是 <code>pod lib create</code></p>
<p>那么接下来就让我们愉快的创建第三方库吧</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>cocoapods 版本号高于1.0.0</li>
<li>安装了Xcode，貌似需要使用 Xcode 的命令行工具，所以 Xcode 是必须的</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>打开命令行，输入 <code>pod lib create YourFrameworkName</code></p>
<ul>
<li>如果你要检测对应环境是否有已有的被pod化的库和你冲突的话，你可以在后面加上<code>--template-url=URL</code> ，其中 URL 是你所需要检测的版本库的 git 地址，默认检测的是 github 上面的版本库（地址为<a href="https://github.com/CocoaPods/pod-template.git）" target="_blank" rel="external">https://github.com/CocoaPods/pod-template.git）</a></li>
</ul>
</li>
<li><p>之后他会显示以下内容</p>
<blockquote>
<p>What language do you want to use?? [ Swift / ObjC ]        //语言类型</p>
<p>objc</p>
<p>Would you like to include a demo application with your library? [ Yes / No ]        //生成Demo</p>
<p>yes</p>
<p>Which testing frameworks will you use? [ Specta / Kiwi / None ]        //测试库</p>
<p>Kiwi</p>
<p>Would you like to do view based testing? [ Yes / No ]        //UI Test库</p>
<p>NO</p>
<p>What is your class prefix?        //类名前缀</p>
<p>AS</p>
</blockquote>
</li>
<li><p>输入完这些后他就会帮下拉你所需要建立的第三方库，并帮你打开你所需要的workSpec。</p>
</li>
<li>然后你可以在你的workSpec中的Pods类中，创建你想要创建的第三方库文件</li>
</ol>
<blockquote>
<p>文件目录中的Development Pods是用来存储所有framework资源的，其中你的库名中存放的是你的类文件，你可以进行创建<br>Resource 中的是你的媒体文件。如果没有则手动创建一个，名字为 Resources，里面的 ClassName/Assets 是用来存放媒体文件的，包括图片和 多国语言<br>每次在 Demo 文件中引用了新创建的文件内容，需要进行 pod install ，这样就可以直接在 Demo 中直接调用了。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/28/使用coocapods1-1-1无法成功创建pod工程文件的解决方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/28/使用coocapods1-1-1无法成功创建pod工程文件的解决方法/" itemprop="url">使用coocapods1.1.1无法成功创建pod工程文件的解决方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-28T22:17:52+08:00">
                2016-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在开发的过程中由于手贱将系统工程删了，然后再次重新<code>git clone</code>下拉工程并使用 cocoapods 进行对第三方库的安装，然而失败了。错误代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Generating Pods project</div><div class="line">[1]    93845 abort      pod install</div></pre></td></tr></table></figure>
<p>经过大佬的提醒，仔细看了下公司机子仍旧能够正确使用 cocoapods ，同时 cocoapods 也无法正确下拉我以前写好的代码，所以最后问题归结到 cocoapods 上面，然后各种胡乱下载。导致就连最基本的 pod 代码都无法使用，现象如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/Library/Ruby/Site/2.0.0/rubygems/dependency.rb:308:in `to_specs&apos;: Could not find &apos;cocoapods&apos; (&gt;= 0) among 50 total gem(s) (Gem::MissingSpecError)</div><div class="line">Checked in &apos;GEM_PATH=/Users/*username*/.gem/ruby/2.0.0:/Library/Ruby/Gems/2.0.0:/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0&apos;, execute `gem env` for more information</div><div class="line">	from /Library/Ruby/Site/2.0.0/rubygems/dependency.rb:320:in `to_spec&apos;</div><div class="line">	from /Library/Ruby/Site/2.0.0/rubygems/core_ext/kernel_gem.rb:65:in `gem&apos;</div><div class="line">	from /usr/local/bin/pod:22:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure>
<p>很明显被我玩坏了，┑(￣Д ￣)┍</p>
<p>所以没办法继续搜方法。</p>
<p>根据 stackOverflow 上面的介绍，应该是 ruby 2.0.0 和 cocoapods 相冲突导致的 bug 。那就按照原来的方法升级下 ruby 就好了。</p>
<p><strong>解决方法</strong></p>
<ol>
<li><p>首先删除现在已经有的 cocoapods ，由于安装 cocoapods 的时候距离现在已经很久，所以搜了下相关的内容。发现 cocoapods 不仅仅只有一个 cocoapods 主件，还有其他一起的插件。仔细想想貌似之前只删除了 cocoapods 的内容。所以导致 pod 都无法使用。在terminal中输入下面的代码，必要的时候可以使用sudo。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gem uninstall cocoapods</div><div class="line">gem uninstall cocoapods-core</div><div class="line">gem uninstall cocoapods-deintegrate</div><div class="line">gem uninstall cocoapods-downloader</div><div class="line">gem uninstall cocoapods-plugins</div><div class="line">gem uninstall cocoapods-search</div><div class="line">gem uninstall cocoapods-stats</div><div class="line">gem uninstall cocoapods-try</div><div class="line">gem uninstall cocoapods-trunk</div></pre></td></tr></table></figure>
</li>
<li><p>​完成了上面这个步骤，我们基本上原有的cocoapods已经删光了，接下来就是安装新版本。首先输入<code>gem install cocoapods --pre</code>,安装cocoapods，这个时候装的是上一个新的release版本的cocoapods。</p>
</li>
<li>当然对于很久以前使用的ruby用户，由于引用的源是ruby的官方源，但是因为是墙外，同时距离又远，所以可能会十分慢，而网上的ruby-china的源貌似请求也是失败的，而老的淘宝源已经过期了，所以，这里更新为新的阿里云的数据源（每隔15分钟更新一次）地址是:<code>https://rubygems-china.oss.aliyuncs.com/</code>，你可以直接访问查看下，但是他首页的命令还是老的淘宝，所以需要更新下。你可以尝试使用下面这条命令来进行修改:<ul>
<li>使用<code>gem sources -l</code>来查看你的现在保存的源的路径：yourPath。</li>
<li>然后使用<code>gem sources --remove yourPath</code>删除现有源</li>
<li>使用<code>gem sources -a https://rubygems-china.oss.aliyuncs.com/</code>来添加新的源，这样你就可以调用国内的源</li>
<li>gem install rails</li>
</ul>
</li>
<li>这里我遇到了一个问题，我的ruby版本太低，导致了无法安装cocoapods（我以前到底是怎么装上的，(╯‵□′)╯︵┻━┻）</li>
<li>然后我就安装用rvm(ruby version management)来进行ruby的版本管理。<ul>
<li>在命令行中输入<code>$ curl -L get.rvm.io | bash -s stable</code></li>
<li>过了一段时间，就安装完了，然后设置全局命令</li>
<li><code>source ~/.bashrc</code> 和 <code>source ~/.bash_profile</code>用来设置当前用户和全局命令。</li>
<li>使用 <code>rvm -v</code> 来测试是否正确安装。</li>
</ul>
</li>
<li>首先使用<code>rvm list known</code>来查看所有的ruby版本</li>
<li>然后使用<code>rvm install version</code>就能愉快的安装了。</li>
<li>然而后面有个坑，不知道是什么问题导致，最后还是出现了问题，所以我借鉴了<a href="http://www.jianshu.com/p/17aa1c6b27c0" target="_blank" rel="external">这篇文章</a>，最后将源添加为最开始的国外官方源，然后使用<code>sudo pod install cocoapods --pre</code>，安装了cocoapods 1.2.0 beta-3。最后能够成功安装。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/27/iOS-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/27/iOS-tips/" itemprop="url">iOS tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-27T22:07:34+08:00">
                2016-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>列出开发中常见bug，方便以后review</p>
<ol>
<li><code>Linker command failed with exit code 1 (use -v to see invocation)</code> 由于link出现问题</li>
</ol>
<ul>
<li>原因：submodule和pod同时存在，导致编译器不知道去哪个地方进行调用。解决方法：删除其中一个，个人建议删除submodule，然后用command+option+shift+k，删除所有已经build文件，然后重新build，因为更加简单。</li>
<li>根据提醒，文件重复，原因是文件产生的文件名冲突，导致产生的.a之类的文件冲突。</li>
</ul>
<ol>
<li>ImageNamed会进行缓存，不仅仅从Assets中读取，也从路径中读取，不需要加2x等后缀，contentOfFile:需要完整路径，需要加上2x后缀。</li>
<li>使用newView.layer.shouldRasterize = YES虽然使用栅栏化，但是因为栅栏化导致图片变得模糊，同时模糊的对象除了本身还有其包含的UIView的子类。所以最好的建议在大量使用圆角的时候，如果图片小，可以使用shouldRasterize，否则最好使用CAShapeLayer进行重新绘制。虽然还是会调用上下文，但是因为是用户设置好告诉系统需要调用，所以减少卡顿效果</li>
<li>tableView &amp; collectionView 的 cell 的size 都是通过计算获得，苹果方面禁止对 cell 直接使用使用 autolayout。</li>
<li>cell 中的 imageView 的 superView 是 contentView ，而 contentView 的superView 才是 Cell。所以当内容插入的时候，需要将内容插入到 contentView 而不是直接插入到 cell 当中，否则在调试 UI 的过程中，控件的状态像是 存在于 Layer 上面一样。</li>
<li>对于懒加载的使用情况。主要是为了应对一个 VC 下面有多种的 View 的现实情况，而不同的 View 的出现概率不一定，所以为了节省空间而使用懒加载。</li>
</ol>
<ul>
<li>缺点：但是因为懒加载重写了 getter 方法，如果在书写的过程中不按照规范书写，导致返回值发生变化。这样父类调用子类的情况可能没有问题，但是父类调用子类的子类，就可能会出现问题。</li>
<li>需要注意：在只需要加载一次的情况下，就直接创建对象并赋值。</li>
</ul>
<ol>
<li>尽可能使用全称来进行描述变量，比如说：使用<code>button</code>而不是<code>btn</code>。</li>
<li>对于pod 1.0以上版本在bundle内直接使用<code>NSLocalizedString(arg1,arg2)</code>可能会无法读取，所以取而代之用<code>NSLocalizedStringFromTableInBundle(@&quot;goback&quot;, nil, bundle, nil);</code>进行获取相关内容的<strong>i18n</strong>。</li>
<li>对于alias命令使用.bash_profile进行转化（对于单个用户），/etc/podfile 对全体用户进行转化。</li>
<li>对于不同类型的 asset 转换成 CGImage（图片质量从高到低分别是）：</li>
</ol>
<ul>
<li>[UIImage imageWithCGImage:[[asset defaultRepresentation] fullResolutionImage]]，直接获得原图，不经过相册自带修改的信息，非 PNG 格式</li>
<li>[UIImage imageWithCGImage:[[asset defaultRepresentation] fullScreenImage]]，获得缩略图，经过相册自带修改信息的处理<ul>
<li>[UIImage imageWithCGImage:[asset aspectRatioThumbnail]]，获得分辨率约为 380 * 250 的图片</li>
<li>[UIImage imageWithCGImage:[asset thumbnail]] ，获得 125 * 125的缩略图。</li>
</ul>
</li>
</ul>
<ol>
<li>对于正确使用ssh的添加方法：</li>
</ol>
<ul>
<li>ssh -T git@git.caimi-inc.com 对git进行测试判断是否正常</li>
<li>ssh-keygen -t rss -C “注释名“ 创建一个名字<ul>
<li>里面的创建的名字不需要使用路径名字，直接输入文件名即可</li>
<li>创建完后加入最后ssh-add privateKeyName，然后上传即可</li>
</ul>
</li>
</ul>
<ol>
<li><p>podspace 的基本情况：通过 ruby 书写。明白了版本号的区别（语义化版本），详见网页地址</p>
</li>
<li><p>就算是系统内部的函数也存在循环引用的情况，<code>[[NSNotificationCenter defaultCenter] addObserverForName:&lt;#(nullable NSString *)#&gt; object:&lt;#(nullable id)#&gt; queue:&lt;#(nullable NSOperationQueue *)#&gt; usingBlock:&lt;#^(NSNotification * _Nonnull note)block#&gt;]</code> 方法因为返回一个observer对象会导致self，持有这个对象，从而导致环的出现。</p>
</li>
<li><p>brew install imagemagick。图片转换，使用方法: convert -resize 50% sourcePath aimPath;</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dyld: Library not loaded: @rpath/XCTest.framework/XCTest**</div><div class="line"></div><div class="line">**  Referenced from: /Users/zkhcreator/Library/Developer/CoreSimulator/Devices/475FB229-B4DF-41AA-B3B9-263F47E7FEA2/data/Containers/Bundle/Application/6670C0B5-2E68-4F43-B0AD-5C78ABD3D78E/WacApp.app/WacApp**</div><div class="line"></div><div class="line">**  Reason: image not found**</div><div class="line"></div><div class="line">解决方法：在对应工程文件中Build Phases中高的Link Binary With Libraries中添加XCTest.framework，由于在这个工程文件中不存在对应内容，所以status设置为optional。</div></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/25/计算机网络基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/25/计算机网络基础/" itemprop="url">计算机网络基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-25T15:49:16+08:00">
                2016-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、单词拼写<br>  WAN = Wide Area Network 广域网<br>  Man = Metropolitan Area Network 城域网<br>  Lan = Local Area Network  局域网<br>  Pan = Personal Area Network 个人区域网<br>  ADSL = Asymmetric Digital Subscriber Line 非对称数字用户线<br>  CRC = Cyclic Redundancy Check 循环冗余检测<br>  PPP = Point-to-Point Protocol 点对点协议<br>  CSMA/CD = Carrier Sense Multiple Access with Collision Detection 载波监听多点接入/碰撞检测<br>  ARP = Address Resolution Protocol 地址解析协议<br>  ICMP = Internet Control Message Protocol 网际控制报文协议<br>  IGMP = Internet Group Management Protocol 网际组管理协议<br>  TTL = Time To Live 生存时间<br>  RIP = Routing Information Protocol 路由信息协议<br>  OCPF = Open Shortest Path First 开放最短路径优先<br>  IGMP = Internet Group Management Protocol 网际组管理协议<br>  NAT = Network Address Translation 网络地址转换<br>  UDP = User Datagram Protocol 用户数据报协议<br>  TCP = Transmission Control Protocol 传输控制协议<br>  DNS = Domain Name System 域名系统<br>  FTP = File Transfer Protocol 文件传送协议<br>  WWW = World Wide Web 万维网<br>  URL = Uniform Resource Locator 统一资源定位符<br>  HTTP = HyperText Transfer Protocol 超文本传输协议<br>  HTML = HyperText Markup Language 超文本标记语言<br>  SMTP = Simple Mail Transfer Protocol 因特网文本报文格式<br>  Mime = Multipurpose Internet Mail Extensions 通用因特网邮件扩充</p>
<p>二、知识要点<br>第一章 总述<br>  1.1 电路交换：通话的全部时间内，通话的两个用户始终占用端到端的通信资源。一般用于电话线路，面向连接。<br>  1.2 分组交换：是报文交换的一部分，使用存储转发技术，发送到整个数据块称为报文。如果报文较长，会将报文分为几个小的等长的数据段。然后在每个数据段前加上必要的控制信息形成首部，构成分组。分组成为“包”，首部成为“包头”，面向无连接。<br>  1.3 电路交换，报文交换，分组交换的区别：P16。<br>  1.4 网络性能指标：P17</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1、速率</div><div class="line">  单位为 b/s 比特每秒 比特为一个二进制数字，有时候也写成bps（bit per second）或者bit/s。所以一般100M以太网为100Mb/s的以太网，所以为1*10^6b/s。所以在实际计算速率的时候还需要除以8</div><div class="line">2、带宽</div><div class="line">  一般用来表示信号具有的频带宽度，但是在计算机中为从某一点到另一点所能通过的“最高数据率”。前者为频域称谓，后者为时域称谓。</div><div class="line">3、吞吐量</div><div class="line">  吞吐量受网络的带宽或网络的额定速率的限制。一般100Mb/s的以太网，典型的吞吐量只有70Mb/s。</div><div class="line">4、时延</div><div class="line">  1）发送时延，主机或路由器发送数据帧所需要的时间。 发送时延 = 数据帧长度(b)/发送速率(b/s);</div><div class="line">  2）传播时延，电磁波在信道传播一定距离需要花费的时间。 信道长度(m)/电磁波在信道上的传播速率(m/s);</div></pre></td></tr></table></figure>
<p>  1.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OSI协议：（从上往下）应用层，表示层，会话层，运输层，网路层，数据链路层，物理层</div><div class="line">TCP/IP： 应用层，运输层，网络层，网络接口层。</div><div class="line">五层协议：（一般学习计算机网络原理的时候用到，综合OSI和TCP/IP的优点） 应用层，传输层，网络层，数据链路层，物理层。</div></pre></td></tr></table></figure>
<p>第二章 物理层<br>  2.1 物理层主要特性：机械特性，电气特性，功能特性，过程特性。<br>  2.2 一条通信电路包含了一条发送信道和一条接受信道  P40</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1）单向通信，单工通信：无限广播，有线广播，电视广播。</div><div class="line">2）双向交换通信，半双工通信：单位时间只能一方发送，一方接受。</div><div class="line">3）双向同时通信，全双工通信：双向同时接受和发送数据。</div></pre></td></tr></table></figure>
<p>  2.3 基本的带通调制方法：P41</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1）调幅  AM</div><div class="line">2）调频  FM</div><div class="line">3）调相  PM</div><div class="line">此处应有图片</div></pre></td></tr></table></figure>
<p>  2.4 引导传输媒体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、双绞线，同轴电缆，光缆。常用网线接口RJ45,接口类型没找到位置。</div><div class="line">2、光缆传播原理：光的全反射。</div></pre></td></tr></table></figure>
<p>  2.5 信道复用技术 P50</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1)频分复用</div><div class="line">  FDM (Frequency Division Multiplexing)。所有用户在同样的时间占用不同的带宽资源。</div><div class="line">2)时分复用</div><div class="line">  TDM (Time Division Multiplexing)。所有用户在不同的时间占用相同的带宽资源。</div><div class="line">3)波分复用</div><div class="line">  WDM (Wavelength Division Multiplexing)。一根光纤传输多个很接近的光载波信号。</div><div class="line">4)码分复用</div><div class="line">  CDM (Code Division Multiplexing)。同样的时间使用经过特殊挑选的不同码型，各用户使用经过特殊挑选的不同码型，因此个用户之间不会造成干扰。</div><div class="line">  计算方法，原理待定：</div></pre></td></tr></table></figure>
<p>  2.6 ADSL特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用数字技术对现有的模拟电话用户线进行改造。可以利用电话网中的用户线，不需要重新布线。如果使用电话网，则需要使用电话分离器，有3个RJ-11插口，用来将电话线和网络通讯的线分离。</div></pre></td></tr></table></figure>
<p>第三章 数据链路层<br>  3.1 三个基本问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1）封装成帧：在一段数据的前后分别添加了首部与尾部。作用是进行帧定界。同时每一种链路层协议规定了所能传送帧的数据部分长度上线——最大传送单元MTU。</div><div class="line">2）透明传输：防止因为数据中出现帧定界从而导致错误，所以在前面加个**转移字符“ESC”**。</div><div class="line">3）差错检测：传输错误的比特占所传输比特总数的比率成为：误码率（五马路233333）。例，当误码率为10^(-10)时候则表示每10^(-10)出现一个比特的错误。</div><div class="line">  检错方法：循环冗余检测CRC(Cyclic Redundancy Check)。P70;</div><div class="line">  产生冗余码的方法：双方商定除数P（n+1位），现在数据后面补n个0产生被除数，然后，用除数去除被除数，生成余数，最后将余数即**帧检验序列FCS(Frame Check Sequence)**，补到数据后面。</div><div class="line">  这样进行CRC即用有冗余码的数据去除P，余数一定为0。那么没有丢失。</div><div class="line">  缺点：可能出现传输差错，即传输的是1-2-3，接受到得是 1-3 或 1-2-2-3。</div><div class="line">  解决方法：在通信良好的有线传输线路， 修改差错通过上层（例如TCP完成）；在通讯不良的无线线路，修改差错通过数据链路层协议使用确认重传机制。P72</div></pre></td></tr></table></figure>
<p>  3.2 PPP协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">特点：1、简单 2、封装成帧 3、透明性 4、多种网络层协议 5、多种类型链路 6、差错检测 7、检测连接状态 8、最大传送单元 9、网络层地址协商 10、数据压缩协商</div><div class="line">格式如下图</div><div class="line">1）各字段的意义：首部F(7E)表示定界符，A(FF),C(03)没有实际意义。协议为0x0021为IP数据报，0xC021为LCP的数据，0x8021表示这是网络层的控制数据。尾部第一个FCS为帧检验序列。7E为定界符，若两个定界符中间为空，则舍弃。</div><div class="line">2）字节填充：将小于0x20的字符前面加入0x7D,然后增加一个将字符的编码加以改变。</div><div class="line">3）零比特填充：为了实现透明传输，在发送端，每5个连续的1之后增加一个0。接受端正好相反。</div></pre></td></tr></table></figure>
<p>  3.3 CSMA/CD协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">要点：1、多点接入 2、载波监听 3、碰撞检测</div><div class="line">因为电磁波有传播速率，1KM电缆传播时延为5μs，最差情况，两倍的总线端到端的传播时延（2T）</div><div class="line">该协议只能进行半双工通信，不能进行全双工通信。</div><div class="line"></div><div class="line">常见设备的分类：</div><div class="line">链路层：集线器，网桥</div><div class="line">物理层：中继器，中继器</div><div class="line">网络层：路由器</div></pre></td></tr></table></figure>
<p>  3.4 网桥与透明网桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">网桥：网桥通过转发表来转发帧。</div><div class="line">  好处：</div><div class="line">    1、过滤通信量，增大吞吐量。</div><div class="line">    2、扩大屋里范围</div><div class="line">    3、提高可靠性</div><div class="line">    4、互联不同物理层、不同MAC子层和不同速率</div><div class="line">透明网桥：只要将网桥接入局域网，不用人工配制转发表网桥就能工作。拥有自学习算法</div><div class="line">  自学习算法：若从某个站A发出的帧，从接口x进入了某网桥，那么从这个接口出发沿反方向一定可把一个帧传送到A。所以网桥只要每收到一个帧，就记下起**源地址**和**进入网桥的接口**。</div><div class="line">  例子：P97,如何解决从A-&gt;B。疑问：但B从来没有收到的A的消息同时B也没有发出过。</div><div class="line">  相关内容可以看P111 3-32</div></pre></td></tr></table></figure>
<p>第四章 网络层<br>  4.1 虚电路服务的3点 P114,表4-1（没看过，不太懂，先留着）<br>  4.2 A类1.0.0.0~126.0.0.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">B类128.0.0.0~191.255.255.255</div><div class="line">C类192.0.0.0~223.255.255.255</div></pre></td></tr></table></figure>
<p>  4.3 IP地址与MAC地址的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。</div><div class="line">消息在传输的过程中,传输过程如下图：</div><div class="line">则在此过程中IP的源地址与目的地址固定不变，数据在R1,R1中的时候，源地址为发送机子的MAC地址，目的地址为下一个接受到该消息的MAC地址。</div></pre></td></tr></table></figure>
<p>  4.4 ARP协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">从网络层使用的IP地址解析出数据链路层使用的硬件地址(MAC地址)。</div><div class="line">每一个主机都有一个ARP高速缓存，用来动态记录IP地址与MAC地址之间的关系。通过广播的方式获取对应的IP地址对应的MAC地址，并将自己的IP与MAC地址传输出去。</div></pre></td></tr></table></figure>
<p>  4.5 IP数据包头（考试考到可能性不大，不过入职面试时候需要）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1）版本，占4位，IP版本。IPv4则为4，IPv6则为6。</div><div class="line">2）首部长度。永远在4字节的整数倍的时候开始，一般为20字节。4位。</div><div class="line">3）区分服务，一般不使用，经常性使用在区分服务（8.4.4节）；</div><div class="line">4）总长度，首部和数据之和的长长度，单位为字节。总长度为16位，最大长度为65535字节。</div><div class="line">5）标识，16位，IP软件在存储器中维持一个计数器，每产生一个数据包，计数器就加一。相同标识字段的值使分片后的各数据报片最后能正确重新组装为原来的数据报。</div><div class="line">6）标志，占3位，现在只有2位有意义。最低位MF(More Fragment)为1则说明后面还有分片，否则说明是最后一个分片。中间一位DF（Don&apos;t Fragment），不能分片，即只有DF=0时候才能分片。</div><div class="line">7）片偏移，13位，较长组分片后，某片在缘分组中的相对位置。值为起始字节的位置除以8。</div><div class="line">8）生存时间TTL，8位。每经过一个路由器,TTL减一。</div><div class="line">9）协议，8位，携带的是哪种协议，表格如下，一般用来判断是什么协议，ICMP,IGMP,IP,TCP,UDP......</div><div class="line">10）首部检验和，16位，只检验数据报的首部，但不包括数据部分。不采用CRC校验码。</div><div class="line">  采用的方法是：发送端检验和置0，然后通过反码运算求和16位，然后放到检验位中。</div><div class="line">              接收端反码算数运算求和取反码后得到结果为0，则保留，否则丢弃。</div><div class="line">11）源地址，32位。</div><div class="line">12）目的地址，占32位。</div></pre></td></tr></table></figure>
<p>  4.6 子网划分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">原因：</div><div class="line">  1）IP地址空间的利用率有时很低</div><div class="line">  2）给每一个物理网络分配一个网络号会使**路由表变得太大**因而使网络性能变坏</div><div class="line">  3）两级IP地址不够灵活</div></pre></td></tr></table></figure>
<p>  4.7 子网掩码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">只要通过子网掩码与收到的数据报的目的IP地址逐位相**“与(AND)”**</div><div class="line">A类地址的默认子网掩码是255.0.0.0</div><div class="line">B类地址的默认子网掩码是255.255.0.0</div><div class="line">C类地址的默认子网掩码是255.255.255.0</div><div class="line">相同的IP地址和不同的子网掩码可以得出相同的网络地址，P138 4-2 4-3</div><div class="line">//疑问：网络地址，IP地址的区别</div><div class="line">分组时转发：P139</div></pre></td></tr></table></figure>
<p>  4.8 CIDR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IP地址 ::=&#123;&lt;网路前缀&gt;,&lt;主机号&gt;&#125;</div><div class="line">斜线记法（CIDR记法）在IP后加上/，写上网络前缀所占的位数。</div><div class="line">好处：将网络前缀缩短，其地址块包含的地址数就越多。</div><div class="line">可见 P142表4-7</div></pre></td></tr></table></figure>
<p>  4.9 ICMP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">作用：为了更有效的转发IP数据报和提高交付成功的机会。</div><div class="line">主要分2种：**ICMP差错报告报文**和**ICMP询问报文**。</div><div class="line">主要组合在IP数据报的数据字段。具体可见下图：</div><div class="line">主要应用地点：PING和TRACERT</div></pre></td></tr></table></figure>
<p>  4.10 路由协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">RIP协议：分布式的基于距离向量的路由选择协议</div><div class="line">  特点：</div><div class="line">  1）仅和**相邻**的路由器交换信息</div><div class="line">  2）路由器交换的信息是**当前版本路由器所知道的全部信息，即自己的路由表**</div><div class="line">  3）**按固定的时间间隔**交换路由信息</div><div class="line">RIP算法：</div><div class="line">  1）对于地址为X的相邻路由器发来的RIP报文，把吓一跳地址都改为X，并把所有的“距离”的值都加一。每个项目包含：到目的网络N，距离是d，下一跳路由器是X</div><div class="line">  2）若原来的路由表没有则添加，</div><div class="line">      否则比较，</div><div class="line">        若吓一跳路由地址是X，则把收到的项目替换路由表中的项目</div><div class="line">        否则（即这个项目是：到目的网络N，但吓一跳路由器不是X）</div><div class="line">          若收到的项目中的距离d小于路由表中的距离，则进行更新，</div><div class="line">          否则什么都不做</div><div class="line">  3）若3分钟还没有收到相邻路由器的更新路由表，则把此项林路由器记为不可到达的路由器，即把距离设为16</div><div class="line">  4）返回</div><div class="line">RIP协议使用运输层的用户数据报UDP进行传送，UDP端口为520</div></pre></td></tr></table></figure>
<p>  4.11 OSPF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">OSPF 开放最短路径优先，主要的特征是：使用分布式的链路状态协议。</div><div class="line">要点（和RIP不一样的3各要点）：</div><div class="line">  1）向本自治系统中**所有路由器**发送信息。</div><div class="line">  2）发送的信息就是与本路由器**相邻的所有路由器的了链路状态**</div><div class="line">  3）只有当链路状态**发生变化**，路由器才向所有路由器用洪泛法发送此信息。</div></pre></td></tr></table></figure>
<p>  4.12 路由器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">路由器的基本结构如下图：</div><div class="line">左侧1 2 3 分别为物理层，数据链路层，网络层</div><div class="line">路由器的基本配置，详见实验课。</div></pre></td></tr></table></figure>
<p>  4.13 多播</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">概念：有许多的应用需要由一个原点发送到许多个终点，即一对多通信。例如，实时信息的交付。</div><div class="line">相对于单播，多播的服务器只需要发送一次，在路由器（需支持多播协议）转发的时候进行复制。</div><div class="line">多播IP地址是：224.0.1.0~238.255.255.255</div><div class="line">多播地址对你硬件多播，需要2个协议：IGMP协议和多播路由选择协议</div><div class="line">前者用来知道多播组的成员信息，后者用来以最小代价传送给所有组成员。</div><div class="line">P.S.隧道技术，把数据封装成一个，到达另一个端点时候解封。</div></pre></td></tr></table></figure>
<p>  4.14 VPN 与 NAT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VPN与NAT和上一节的隧道有异曲同工之处，</div><div class="line">都是通过数据加密，然后在端点进行解密，从来进行虚拟专用网。</div><div class="line">NAT工作方式如下图：</div></pre></td></tr></table></figure>
<p>第五章 运输层<br>  5.1 两个主要的协议UDP,TCP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UDP传输数据之前不需要建立连接。TCP则提供面向连接的服务。</div><div class="line">应用层对应的协议与运输层协议之间的关系表，如下图：</div></pre></td></tr></table></figure>
<p>  5.2 常见端口号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FTP 21</div><div class="line">TELNET 23</div><div class="line">SMTP 25</div><div class="line">DNS 53</div><div class="line">TFTP 69</div><div class="line">HTTP 80</div><div class="line">SNMP 161</div><div class="line">SNMP(TRAP)162</div><div class="line"></div><div class="line">P.S.系统端口号为0~1023，登记端口号为1024~49151，客户端使用的端口号49152~65535。</div></pre></td></tr></table></figure>
<p>  5.3 UDP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1）无连接</div><div class="line">2）尽最大努力交付</div><div class="line">3）面向报文</div><div class="line">4）没有拥塞控制</div><div class="line">5）支持一对一，一对多，多对一，多对多的交互通信</div><div class="line">6）首部开销小</div></pre></td></tr></table></figure>
<p>  5.4 TCP:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1）面向连接的运输层协议</div><div class="line">2）每一条TCP连接只能有2个端点</div><div class="line">3）提供可靠交付</div><div class="line">4）提供双工通信</div><div class="line">5）面向字节流</div><div class="line">TCP面向流概念如下图：</div></pre></td></tr></table></figure>
<p>  5.5 TCP报文首部格式（考试应该不考）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1）源端口和目的端口，各占2字节（共32位）</div><div class="line">2）序号，报文序号段，32位。本报文段所发送的数据的第一个字节的序号。</div><div class="line">3）确认号，4字节（32位），**期望收到对方下一个报文段的第一个数据字节的序号**。若确认号为N，则表明序号N-1为止的所有数据都已正确收到。</div><div class="line">4）数据偏移，占4位，TCP报文段的数据起始处距离TCP报文段的起始处有多远。作用是指出TCP报文段的首部长度。</div><div class="line">5）保留，6位，目前为0，今后使用</div><div class="line">6）URG，紧急，为1，有紧急数据，不按照原来的排队顺序进行传送，应尽快传送</div><div class="line">7）ACK，确认，为1，号字段有效，否则为无效</div><div class="line">8）PSH，推送，发送方TCP把PSH置1，新建一个报文段发送出去。接受方收到，就尽快交付接受的应用程序。一般少用</div><div class="line">9）RST，复位，为1，表明出现严重差错，释放连接，重新连接。</div><div class="line">10）SYN，同步，SYN=1,ACK=0表明是一个连接请求报文，若同意连接，则在响应的报文段中使SYN=1,ACK=1.</div><div class="line">11）FIN，终止，为1，释放链接。</div><div class="line">12）窗口，2字节（16位），窗口大小，在下一节有具体解释。</div><div class="line">13）检验和，2字节检验和字段检验的范围包括首部和数据这两部分。</div><div class="line">14）紧急指针，当URG为1的时候有用，指出紧急数据的末尾在报文段中的位置。</div><div class="line">15）选项，长度可变，最长40字节。没有使用时，TCP首部为20字节。</div></pre></td></tr></table></figure>
<p>  5.6 TCP的可靠传输原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">TCP连接有2个端点，称为**“套接字(socket)”**或**插口**。</div><div class="line">  socket = (IP地址：端口号)，例如：192.3.4.6:80。</div><div class="line">  TCP连接 ::= &#123;socket1,socket2&#125; = &#123;(IP1:port),(IP2:port2)&#125;</div><div class="line">可靠传输原理：</div><div class="line">1）停止等待协议</div><div class="line">  接收方收到消息，发送确认消息返回给发送方，发送方在收到确认消息再发送下一个。若超时，则进行重传。</div><div class="line">  要点：</div><div class="line">  1、发送方发送完分组后需要保留发送分组的副本。</div><div class="line">  2、分组和确认分组都必须进行编号，草能明确是哪一个发送出去的分组，从而确定哪个分组还没收到确认。</div><div class="line">  3、超时重传时间应当比**数据在分组传输的平均往返时间更长一点**。</div><div class="line">  缺点：因为一个发送完再发送下一个，效率太低。</div><div class="line">2）连续ARQ协议</div><div class="line">  位于发送窗口内的N各分组都可以连续发送出去，而不需要等待对方确认，而当发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</div><div class="line">可靠传输实现：</div><div class="line">1）以字节为单位的滑动窗口</div><div class="line">2）超时重传时间的选择</div><div class="line">3）选择确定SACK</div><div class="line">实现方法根据上课表演。</div></pre></td></tr></table></figure>
<p>  5.7 TCP流量控制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">流量控制，通过接收方返回rwnd来设置窗口大小。从而控制流量。</div><div class="line">拥塞控制，放置过多的数据注入到网络中，这样可以使网络中的路由器和链路不至过载。</div><div class="line">  方法：</div><div class="line">  1）慢开始</div><div class="line">  2）拥塞避免</div><div class="line">  3）快重传</div><div class="line">  4）快恢复</div><div class="line">  彼此之间的区别，查看P233 5-39。</div></pre></td></tr></table></figure>
<p>  5.8 用三次握手建立TCP连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">见下图：（seq为初始序号，ack是确认号）</div></pre></td></tr></table></figure>
<p>第六章 应用层<br>  DNS,FTP,TELNET,WWW,HTTP,HTML,URL,SMTP,DHCP(动态主机配置)<br>  HTTP报文：请求报文，响应报文，基本结构如下，长度因为各个字段的长度都是不确定而不确定。<br>  1）请求报文：第一行：方法请求资源URL，HTTP版本。有时候使用相对URL，是因为第二行后主机域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">第二行：User-Agent:(浏览器版本)，Connection:close(发送完请求的文档后就可释放连接)</div><div class="line">Accept-Language:cn（用户优先希望得到中文版本的文档）</div><div class="line">Cookie：（网站的识别码）请求报文的最后还有一个空行。</div></pre></td></tr></table></figure>
<p>  2）响应报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">第一行：状态航，HTTP版本，状态码，解释状态码的简单短语</div><div class="line">set-cookie，在浏览器本地设置cookie</div><div class="line">状态码：</div><div class="line">  1xx表示通知纤细的，如请求收到了或正在进行处理</div><div class="line">  2xx表示成功，如接受或知道了。</div><div class="line">  3xx表示重定向，如要完成请求还必须采取进一步行动。</div><div class="line">  4xx表示客户的差错，如请求中又错误的语法或不能完成</div><div class="line">  5xx表示服务器的差错，如服务器失效无法完成请求。</div></pre></td></tr></table></figure>
<p>第十章<br>  ipv6有128位IP</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
